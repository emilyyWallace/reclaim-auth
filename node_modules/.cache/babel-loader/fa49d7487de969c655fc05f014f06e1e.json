{"ast":null,"code":"\"use strict\";\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n    exports: {}\n  }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n// If the importer is in node compatibility mode or this is not an ESM\n// file that has been converted to a CommonJS file using a Babel-\n// compatible transform (i.e. \"__esModule\" has not been set), then set\n// \"default\" to the CommonJS \"module.exports\" for node compatibility.\nisNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod);\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// package.json\nvar require_package = __commonJS({\n  \"package.json\"(exports2, module2) {\n    module2.exports = {\n      name: \"@reclaimprotocol/js-sdk\",\n      version: \"2.2.0\",\n      description: \"Designed to request proofs from the Reclaim protocol and manage the flow of claims and witness interactions.\",\n      main: \"dist/index.js\",\n      types: \"dist/index.d.ts\",\n      keywords: [\"reclaim\", \"protocol\", \"blockchain\", \"proof\", \"verification\", \"identity\", \"claims\", \"witness\", \"sdk\", \"javascript\", \"typescript\", \"decentralized\", \"web3\"],\n      files: [\"dist\"],\n      tsup: {\n        entry: [\"src/index.ts\"],\n        splitting: false,\n        sourcemap: true,\n        clean: true\n      },\n      scripts: {\n        build: \"sh scripts/build.sh\",\n        release: \"release-it\",\n        test: 'echo \"Error: no test specified\" && exit 1',\n        commitlint: \"commitlint --edit\"\n      },\n      repository: {\n        type: \"git\",\n        url: \"https://github.com/reclaimprotocol/reclaim-js-sdk\"\n      },\n      author: \"ali <ali@creatoros.co>\",\n      license: \"See License in <https://github.com/reclaimprotocol/.github/blob/main/LICENSE>\",\n      bugs: {\n        url: \"https://github.com/reclaimprotocol/reclaim-js-sdk/issues\"\n      },\n      homepage: \"https://github.com/reclaimprotocol/reclaim-js-sdk/\",\n      publishConfig: {\n        registry: \"https://registry.npmjs.org/\",\n        access: \"public\"\n      },\n      \"release-it\": {\n        git: {\n          commitMessage: \"chore: release ${version}\",\n          tagName: \"v${version}\"\n        },\n        npm: {\n          publish: true,\n          tag: \"latest\"\n        },\n        github: {\n          release: true\n        },\n        plugins: {\n          \"@release-it/conventional-changelog\": {\n            preset: \"angular\"\n          }\n        }\n      },\n      devDependencies: {\n        \"@bconnorwhite/bob\": \"^2.9.5\",\n        \"@commitlint/cli\": \"^17.7.1\",\n        \"@commitlint/config-conventional\": \"^17.7.0\",\n        \"@release-it/conventional-changelog\": \"^5.0.0\",\n        \"@types/qs\": \"^6.9.11\",\n        \"@types/url-parse\": \"^1.4.11\",\n        \"@types/uuid\": \"^9.0.7\",\n        \"release-it\": \"^15.0.0\",\n        tsup: \"^8.0.1\",\n        typescript: \"^5.3.3\"\n      },\n      dependencies: {\n        canonicalize: \"^2.0.0\",\n        ethers: \"^6.9.1\",\n        qs: \"^6.11.2\",\n        \"url-parse\": \"^1.5.10\",\n        uuid: \"^9.0.1\"\n      }\n    };\n  }\n});\n\n// src/index.ts\nvar index_exports = {};\n__export(index_exports, {\n  ReclaimProofRequest: () => ReclaimProofRequest,\n  transformForOnchain: () => transformForOnchain,\n  verifyProof: () => verifyProof\n});\nmodule.exports = __toCommonJS(index_exports);\n\n// src/witness.ts\nvar import_ethers = require(\"ethers\");\nfunction fetchWitnessListForClaim({\n  witnesses,\n  witnessesRequiredForClaim,\n  epoch\n}, params, timestampS) {\n  const identifier = typeof params === \"string\" ? params : getIdentifierFromClaimInfo(params);\n  const completeInput = [identifier, epoch.toString(), witnessesRequiredForClaim.toString(), timestampS.toString()].join(\"\\n\");\n  const completeHashStr = import_ethers.ethers.keccak256(strToUint8Array(completeInput));\n  const completeHash = import_ethers.ethers.getBytes(completeHashStr);\n  const completeHashView = uint8ArrayToDataView(completeHash);\n  const witnessesLeft = [...witnesses];\n  const selectedWitnesses = [];\n  let byteOffset = 0;\n  for (let i = 0; i < witnessesRequiredForClaim; i++) {\n    const randomSeed = completeHashView.getUint32(byteOffset);\n    const witnessIndex = randomSeed % witnessesLeft.length;\n    const witness = witnessesLeft[witnessIndex];\n    selectedWitnesses.push(witness);\n    witnessesLeft[witnessIndex] = witnessesLeft[witnessesLeft.length - 1];\n    witnessesLeft.pop();\n    byteOffset = (byteOffset + 4) % completeHash.length;\n  }\n  return selectedWitnesses;\n}\nfunction getIdentifierFromClaimInfo(info) {\n  const str = `${info.provider}\n${info.parameters}\n${info.context || \"\"}`;\n  return import_ethers.ethers.keccak256(strToUint8Array(str)).toLowerCase();\n}\nfunction strToUint8Array(str) {\n  return new TextEncoder().encode(str);\n}\nfunction uint8ArrayToDataView(arr) {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\nfunction createSignDataForClaim(data) {\n  const identifier = \"identifier\" in data ? data.identifier : getIdentifierFromClaimInfo(data);\n  const lines = [identifier, data.owner.toLowerCase(), data.timestampS.toString(), data.epoch.toString()];\n  return lines.join(\"\\n\");\n}\n\n// src/Reclaim.ts\nvar import_ethers6 = require(\"ethers\");\nvar import_canonicalize2 = __toESM(require(\"canonicalize\"));\n\n// src/utils/errors.ts\nfunction createErrorClass(name) {\n  return class extends Error {\n    constructor(message, innerError) {\n      super(message);\n      this.innerError = innerError;\n      this.name = name;\n      if (innerError) {\n        this.stack += `\nCaused by: ${innerError.stack}`;\n      }\n    }\n  };\n}\nvar TimeoutError = createErrorClass(\"TimeoutError\");\nvar ProofNotVerifiedError = createErrorClass(\"ProofNotVerifiedError\");\nvar SessionNotStartedError = createErrorClass(\"SessionNotStartedError\");\nvar ProviderNotFoundError = createErrorClass(\"ProviderNotFoundError\");\nvar BuildProofRequestError = createErrorClass(\"BuildProofRequestError\");\nvar SignatureGeneratingError = createErrorClass(\"SignatureGeneratingError\");\nvar SignatureNotFoundError = createErrorClass(\"SignatureNotFoundError\");\nvar InvalidSignatureError = createErrorClass(\"InvalidSignatureError\");\nvar UpdateSessionError = createErrorClass(\"UpdateSessionError\");\nvar InitSessionError = createErrorClass(\"InitSessionError\");\nvar ProviderFailedError = createErrorClass(\"ProviderFailedError\");\nvar InvalidParamError = createErrorClass(\"InvalidParamError\");\nvar ApplicationError = createErrorClass(\"ApplicationError\");\nvar InitError = createErrorClass(\"InitError\");\nvar AvailableParamsError = createErrorClass(\"AvailableParamsError\");\nvar BackendServerError = createErrorClass(\"BackendServerError\");\nvar GetStatusUrlError = createErrorClass(\"GetStatusUrlError\");\nvar NoProviderParamsError = createErrorClass(\"NoProviderParamsError\");\nvar SetParamsError = createErrorClass(\"SetParamsError\");\nvar AddContextError = createErrorClass(\"AddContextError\");\nvar SetSignatureError = createErrorClass(\"SetSignatureError\");\nvar GetAppCallbackUrlError = createErrorClass(\"GetAppCallbackUrlError\");\nvar GetRequestUrlError = createErrorClass(\"GetRequestUrlError\");\nvar StatusUrlError = createErrorClass(\"StatusUrlError\");\nvar ProofSubmissionFailedError = createErrorClass(\"ProofSubmissionFailedError\");\n\n// src/utils/logger.ts\nvar SimpleLogger = class {\n  constructor() {\n    this.level = \"info\";\n  }\n  setLevel(level) {\n    this.level = level;\n  }\n  shouldLog(messageLevel) {\n    const levels = [\"error\", \"warn\", \"info\", \"silent\"];\n    return levels.indexOf(this.level) >= levels.indexOf(messageLevel);\n  }\n  log(level, message, ...args) {\n    if (this.shouldLog(level) && this.level !== \"silent\") {\n      const logFunction = this.getLogFunction(level);\n      console.log(\"current level\", this.level);\n      logFunction(`[${level.toUpperCase()}]`, message, ...args);\n    }\n  }\n  getLogFunction(level) {\n    switch (level) {\n      case \"error\":\n        return console.error;\n      case \"warn\":\n        return console.warn;\n      case \"info\":\n        return console.info;\n      default:\n        return () => {};\n    }\n  }\n  info(message, ...args) {\n    this.log(\"info\", message, ...args);\n  }\n  warn(message, ...args) {\n    this.log(\"warn\", message, ...args);\n  }\n  error(message, ...args) {\n    this.log(\"error\", message, ...args);\n  }\n};\nvar logger = new SimpleLogger();\nfunction setLogLevel(level) {\n  logger.setLevel(level);\n}\nvar logger_default = {\n  logger,\n  setLogLevel\n};\n\n// src/utils/helper.ts\nvar logger2 = logger_default.logger;\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction replaceAll(str, find, replace) {\n  if (find === \"\") return str;\n  return str.replace(new RegExp(escapeRegExp(find), \"g\"), replace);\n}\nfunction scheduleIntervalEndingTask(sessionId, intervals, onFailureCallback, timeout = 1e3 * 60 * 10) {\n  setTimeout(() => {\n    if (intervals.has(sessionId)) {\n      const message = \"Interval ended without receiving proofs\";\n      onFailureCallback(new TimeoutError(message));\n      logger2.info(message);\n      clearInterval(intervals.get(sessionId));\n      intervals.delete(sessionId);\n    }\n  }, timeout);\n}\n\n// src/utils/constants.ts\nvar BACKEND_BASE_URL = \"https://api.reclaimprotocol.org\";\nvar constants = {\n  // Default callback URL for Reclaim protocol\n  DEFAULT_RECLAIM_CALLBACK_URL: `${BACKEND_BASE_URL}/api/sdk/callback?callbackId=`,\n  // Default status URL for Reclaim sessions\n  DEFAULT_RECLAIM_STATUS_URL: `${BACKEND_BASE_URL}/api/sdk/session/`,\n  // URL for sharing Reclaim templates\n  RECLAIM_SHARE_URL: \"https://share.reclaimprotocol.org/verifier/?template=\"\n};\n\n// src/utils/validationUtils.ts\nvar import_ethers2 = require(\"ethers\");\nvar import_canonicalize = __toESM(require(\"canonicalize\"));\nvar logger3 = logger_default.logger;\nfunction validateFunctionParams(params, functionName) {\n  params.forEach(({\n    input,\n    paramName,\n    isString\n  }) => {\n    if (input == null) {\n      logger3.info(`Validation failed: ${paramName} in ${functionName} is null or undefined`);\n      throw new InvalidParamError(`${paramName} passed to ${functionName} must not be null or undefined.`);\n    }\n    if (isString && typeof input !== \"string\") {\n      logger3.info(`Validation failed: ${paramName} in ${functionName} is not a string`);\n      throw new InvalidParamError(`${paramName} passed to ${functionName} must be a string.`);\n    }\n    if (isString && input.trim() === \"\") {\n      logger3.info(`Validation failed: ${paramName} in ${functionName} is an empty string`);\n      throw new InvalidParamError(`${paramName} passed to ${functionName} must not be an empty string.`);\n    }\n  });\n}\nfunction validateURL(url, functionName) {\n  try {\n    new URL(url);\n  } catch (e) {\n    logger3.info(`URL validation failed for ${url} in ${functionName}: ${e.message}`);\n    throw new InvalidParamError(`Invalid URL format ${url} passed to ${functionName}.`, e);\n  }\n}\nfunction validateSignature(providerId, signature, applicationId, timestamp) {\n  try {\n    logger3.info(`Starting signature validation for providerId: ${providerId}, applicationId: ${applicationId}, timestamp: ${timestamp}`);\n    const message = (0, import_canonicalize.default)({\n      providerId,\n      timestamp\n    });\n    if (!message) {\n      logger3.info(\"Failed to canonicalize message for signature validation\");\n      throw new Error(\"Failed to canonicalize message\");\n    }\n    const messageHash = import_ethers2.ethers.keccak256(new TextEncoder().encode(message));\n    let appId = import_ethers2.ethers.verifyMessage(import_ethers2.ethers.getBytes(messageHash), import_ethers2.ethers.hexlify(signature)).toLowerCase();\n    if (import_ethers2.ethers.getAddress(appId) !== import_ethers2.ethers.getAddress(applicationId)) {\n      logger3.info(`Signature validation failed: Mismatch between derived appId (${appId}) and provided applicationId (${applicationId})`);\n      throw new InvalidSignatureError(`Signature does not match the application id: ${appId}`);\n    }\n    logger3.info(`Signature validated successfully for applicationId: ${applicationId}`);\n  } catch (err) {\n    logger3.info(`Signature validation failed: ${err.message}`);\n    if (err instanceof InvalidSignatureError) {\n      throw err;\n    }\n    throw new InvalidSignatureError(`Failed to validate signature: ${err.message}`);\n  }\n}\nfunction validateRequestedProof(requestedProof) {\n  if (!requestedProof.url) {\n    logger3.info(`Requested proof validation failed: Provided url in requested proof is not valid`);\n    throw new InvalidParamError(`The provided url in requested proof is not valid`);\n  }\n  if (requestedProof.parameters && typeof requestedProof.parameters !== \"object\") {\n    logger3.info(`Requested proof validation failed: Provided parameters in requested proof is not valid`);\n    throw new InvalidParamError(`The provided parameters in requested proof is not valid`);\n  }\n}\nfunction validateContext(context) {\n  if (!context.contextAddress) {\n    logger3.info(`Context validation failed: Provided context address in context is not valid`);\n    throw new InvalidParamError(`The provided context address in context is not valid`);\n  }\n  if (!context.contextMessage) {\n    logger3.info(`Context validation failed: Provided context message in context is not valid`);\n    throw new InvalidParamError(`The provided context message in context is not valid`);\n  }\n  validateFunctionParams([{\n    input: context.contextAddress,\n    paramName: \"contextAddress\",\n    isString: true\n  }, {\n    input: context.contextMessage,\n    paramName: \"contextMessage\",\n    isString: true\n  }], \"validateContext\");\n}\n\n// src/utils/sessionUtils.ts\nvar logger4 = logger_default.logger;\nfunction initSession(providerId, appId, timestamp, signature) {\n  return __async(this, null, function* () {\n    logger4.info(`Initializing session for providerId: ${providerId}, appId: ${appId}`);\n    try {\n      const response = yield fetch(`${BACKEND_BASE_URL}/api/sdk/init-session/`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          providerId,\n          appId,\n          timestamp,\n          signature\n        })\n      });\n      const res = yield response.json();\n      if (!response.ok) {\n        logger4.info(`Session initialization failed: ${res.message || \"Unknown error\"}`);\n        throw new InitSessionError(res.message || `Error initializing session with providerId: ${providerId}`);\n      }\n      return res;\n    } catch (err) {\n      logger4.info(`Failed to initialize session for providerId: ${providerId}, appId: ${appId}`, err);\n      throw err;\n    }\n  });\n}\nfunction updateSession(sessionId, status) {\n  return __async(this, null, function* () {\n    logger4.info(`Updating session status for sessionId: ${sessionId}, new status: ${status}`);\n    validateFunctionParams([{\n      input: sessionId,\n      paramName: \"sessionId\",\n      isString: true\n    }], \"updateSession\");\n    try {\n      const response = yield fetch(`${BACKEND_BASE_URL}/api/sdk/update/session/`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          sessionId,\n          status\n        })\n      });\n      const res = yield response.json();\n      if (!response.ok) {\n        const errorMessage = `Error updating session with sessionId: ${sessionId}. Status Code: ${response.status}`;\n        logger4.info(errorMessage, res);\n        throw new UpdateSessionError(errorMessage);\n      }\n      logger4.info(`Session status updated successfully for sessionId: ${sessionId}`);\n      return res;\n    } catch (err) {\n      const errorMessage = `Failed to update session with sessionId: ${sessionId}`;\n      logger4.info(errorMessage, err);\n      throw new UpdateSessionError(`Error updating session with sessionId: ${sessionId}`);\n    }\n  });\n}\nfunction fetchStatusUrl(sessionId) {\n  return __async(this, null, function* () {\n    validateFunctionParams([{\n      input: sessionId,\n      paramName: \"sessionId\",\n      isString: true\n    }], \"fetchStatusUrl\");\n    try {\n      const response = yield fetch(`${constants.DEFAULT_RECLAIM_STATUS_URL}${sessionId}`, {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      const res = yield response.json();\n      if (!response.ok) {\n        const errorMessage = `Error fetching status URL for sessionId: ${sessionId}. Status Code: ${response.status}`;\n        logger4.info(errorMessage, res);\n        throw new StatusUrlError(errorMessage);\n      }\n      return res;\n    } catch (err) {\n      const errorMessage = `Failed to fetch status URL for sessionId: ${sessionId}`;\n      logger4.info(errorMessage, err);\n      throw new StatusUrlError(`Error fetching status URL for sessionId: ${sessionId}`);\n    }\n  });\n}\n\n// src/utils/proofUtils.ts\nvar import_ethers5 = require(\"ethers\");\n\n// src/contract-types/contracts/factories/Reclaim__factory.ts\nvar import_ethers3 = require(\"ethers\");\nvar _abi = [{\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"address\",\n    name: \"previousAdmin\",\n    type: \"address\"\n  }, {\n    indexed: false,\n    internalType: \"address\",\n    name: \"newAdmin\",\n    type: \"address\"\n  }],\n  name: \"AdminChanged\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"beacon\",\n    type: \"address\"\n  }],\n  name: \"BeaconUpgraded\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    components: [{\n      internalType: \"uint32\",\n      name: \"id\",\n      type: \"uint32\"\n    }, {\n      internalType: \"uint32\",\n      name: \"timestampStart\",\n      type: \"uint32\"\n    }, {\n      internalType: \"uint32\",\n      name: \"timestampEnd\",\n      type: \"uint32\"\n    }, {\n      components: [{\n        internalType: \"address\",\n        name: \"addr\",\n        type: \"address\"\n      }, {\n        internalType: \"string\",\n        name: \"host\",\n        type: \"string\"\n      }],\n      internalType: \"struct Reclaim.Witness[]\",\n      name: \"witnesses\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"uint8\",\n      name: \"minimumWitnessesForClaimCreation\",\n      type: \"uint8\"\n    }],\n    indexed: false,\n    internalType: \"struct Reclaim.Epoch\",\n    name: \"epoch\",\n    type: \"tuple\"\n  }],\n  name: \"EpochAdded\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: false,\n    internalType: \"uint8\",\n    name: \"version\",\n    type: \"uint8\"\n  }],\n  name: \"Initialized\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"previousOwner\",\n    type: \"address\"\n  }, {\n    indexed: true,\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"OwnershipTransferred\",\n  type: \"event\"\n}, {\n  anonymous: false,\n  inputs: [{\n    indexed: true,\n    internalType: \"address\",\n    name: \"implementation\",\n    type: \"address\"\n  }],\n  name: \"Upgraded\",\n  type: \"event\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"witnessAddress\",\n    type: \"address\"\n  }, {\n    internalType: \"string\",\n    name: \"host\",\n    type: \"string\"\n  }],\n  name: \"addAsWitness\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"addNewEpoch\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint32\",\n    name: \"epochNum\",\n    type: \"uint32\"\n  }, {\n    components: [{\n      internalType: \"string\",\n      name: \"provider\",\n      type: \"string\"\n    }, {\n      internalType: \"string\",\n      name: \"parameters\",\n      type: \"string\"\n    }, {\n      internalType: \"string\",\n      name: \"context\",\n      type: \"string\"\n    }],\n    internalType: \"struct Claims.ClaimInfo\",\n    name: \"claimInfo\",\n    type: \"tuple\"\n  }, {\n    components: [{\n      internalType: \"bytes32\",\n      name: \"identifier\",\n      type: \"bytes32\"\n    }, {\n      internalType: \"address\",\n      name: \"owner\",\n      type: \"address\"\n    }, {\n      internalType: \"uint32\",\n      name: \"timestampS\",\n      type: \"uint32\"\n    }, {\n      internalType: \"uint256\",\n      name: \"epoch\",\n      type: \"uint256\"\n    }],\n    internalType: \"struct Claims.CompleteClaimData\",\n    name: \"claimData\",\n    type: \"tuple\"\n  }, {\n    internalType: \"bytes[]\",\n    name: \"signatures\",\n    type: \"bytes[]\"\n  }],\n  name: \"assertValidEpochAndSignedClaim\",\n  outputs: [],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"currentEpoch\",\n  outputs: [{\n    internalType: \"uint32\",\n    name: \"\",\n    type: \"uint32\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"epochDurationS\",\n  outputs: [{\n    internalType: \"uint32\",\n    name: \"\",\n    type: \"uint32\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  name: \"epochs\",\n  outputs: [{\n    internalType: \"uint32\",\n    name: \"id\",\n    type: \"uint32\"\n  }, {\n    internalType: \"uint32\",\n    name: \"timestampStart\",\n    type: \"uint32\"\n  }, {\n    internalType: \"uint32\",\n    name: \"timestampEnd\",\n    type: \"uint32\"\n  }, {\n    internalType: \"uint8\",\n    name: \"minimumWitnessesForClaimCreation\",\n    type: \"uint8\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint32\",\n    name: \"epoch\",\n    type: \"uint32\"\n  }],\n  name: \"fetchEpoch\",\n  outputs: [{\n    components: [{\n      internalType: \"uint32\",\n      name: \"id\",\n      type: \"uint32\"\n    }, {\n      internalType: \"uint32\",\n      name: \"timestampStart\",\n      type: \"uint32\"\n    }, {\n      internalType: \"uint32\",\n      name: \"timestampEnd\",\n      type: \"uint32\"\n    }, {\n      components: [{\n        internalType: \"address\",\n        name: \"addr\",\n        type: \"address\"\n      }, {\n        internalType: \"string\",\n        name: \"host\",\n        type: \"string\"\n      }],\n      internalType: \"struct Reclaim.Witness[]\",\n      name: \"witnesses\",\n      type: \"tuple[]\"\n    }, {\n      internalType: \"uint8\",\n      name: \"minimumWitnessesForClaimCreation\",\n      type: \"uint8\"\n    }],\n    internalType: \"struct Reclaim.Epoch\",\n    name: \"\",\n    type: \"tuple\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint32\",\n    name: \"epoch\",\n    type: \"uint32\"\n  }, {\n    internalType: \"bytes32\",\n    name: \"identifier\",\n    type: \"bytes32\"\n  }, {\n    internalType: \"uint32\",\n    name: \"timestampS\",\n    type: \"uint32\"\n  }],\n  name: \"fetchWitnessesForClaim\",\n  outputs: [{\n    components: [{\n      internalType: \"address\",\n      name: \"addr\",\n      type: \"address\"\n    }, {\n      internalType: \"string\",\n      name: \"host\",\n      type: \"string\"\n    }],\n    internalType: \"struct Reclaim.Witness[]\",\n    name: \"\",\n    type: \"tuple[]\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"initialize\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"minimumWitnessesForClaimCreation\",\n  outputs: [{\n    internalType: \"uint8\",\n    name: \"\",\n    type: \"uint8\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"owner\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"\",\n    type: \"address\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"proxiableUUID\",\n  outputs: [{\n    internalType: \"bytes32\",\n    name: \"\",\n    type: \"bytes32\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"witnessAddress\",\n    type: \"address\"\n  }],\n  name: \"removeAsWitness\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [],\n  name: \"renounceOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"newOwner\",\n    type: \"address\"\n  }],\n  name: \"transferOwnership\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"addr\",\n    type: \"address\"\n  }, {\n    internalType: \"bool\",\n    name: \"isWhitelisted\",\n    type: \"bool\"\n  }],\n  name: \"updateWitnessWhitelist\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"newImplementation\",\n    type: \"address\"\n  }],\n  name: \"upgradeTo\",\n  outputs: [],\n  stateMutability: \"nonpayable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"address\",\n    name: \"newImplementation\",\n    type: \"address\"\n  }, {\n    internalType: \"bytes\",\n    name: \"data\",\n    type: \"bytes\"\n  }],\n  name: \"upgradeToAndCall\",\n  outputs: [],\n  stateMutability: \"payable\",\n  type: \"function\"\n}, {\n  inputs: [{\n    internalType: \"uint256\",\n    name: \"\",\n    type: \"uint256\"\n  }],\n  name: \"witnesses\",\n  outputs: [{\n    internalType: \"address\",\n    name: \"addr\",\n    type: \"address\"\n  }, {\n    internalType: \"string\",\n    name: \"host\",\n    type: \"string\"\n  }],\n  stateMutability: \"view\",\n  type: \"function\"\n}];\nvar Reclaim__factory = class {\n  static connect(address, signerOrProvider) {\n    return new import_ethers3.Contract(address, _abi, signerOrProvider);\n  }\n};\nReclaim__factory.abi = _abi;\n\n// src/contract-types/config.json\nvar config_default = {\n  \"0x1a4\": {\n    chainName: \"opt-goerli\",\n    address: \"0xF93F605142Fb1Efad7Aa58253dDffF67775b4520\",\n    rpcUrl: \"https://opt-goerli.g.alchemy.com/v2/rksDkSUXd2dyk2ANy_zzODknx_AAokui\"\n  },\n  \"0xaa37dc\": {\n    chainName: \"opt-sepolia\",\n    address: \"0x6D0f81BDA11995f25921aAd5B43359630E65Ca96\",\n    rpcUrl: \"https://opt-sepolia.g.alchemy.com/v2/aO1-SfG4oFRLyAiLREqzyAUu0HTCwHgs\"\n  }\n};\n\n// src/smart-contract.ts\nvar import_ethers4 = require(\"ethers\");\nvar DEFAULT_CHAIN_ID = 11155420;\nfunction makeBeacon(chainId) {\n  chainId = chainId || DEFAULT_CHAIN_ID;\n  const contract = getContract(chainId);\n  if (contract) {\n    let _a;\n    return makeBeaconCacheable({\n      getState(epochId) {\n        return __async(this, null, function* () {\n          const epoch = yield contract.fetchEpoch(epochId || 0);\n          if (!epoch.id) {\n            throw new Error(`Invalid epoch ID: ${epochId}`);\n          }\n          return {\n            epoch: epoch.id,\n            witnesses: epoch.witnesses.map(w => ({\n              id: w.addr.toLowerCase(),\n              url: w.host\n            })),\n            witnessesRequiredForClaim: epoch.minimumWitnessesForClaimCreation,\n            nextEpochTimestampS: epoch.timestampEnd\n          };\n        });\n      }\n    });\n  } else {\n    return void 0;\n  }\n}\nfunction makeBeaconCacheable(beacon) {\n  const cache = {};\n  return __spreadProps(__spreadValues({}, beacon), {\n    getState(epochId) {\n      return __async(this, null, function* () {\n        if (!epochId) {\n          const state = yield beacon.getState();\n          return state;\n        }\n        const key = epochId;\n        if (!cache[key]) {\n          cache[key] = beacon.getState(epochId);\n        }\n        return cache[key];\n      });\n    }\n  });\n}\nvar existingContractsMap = {};\nfunction getContract(chainId) {\n  const chainKey = `0x${chainId.toString(16)}`;\n  if (!existingContractsMap[chainKey]) {\n    const contractData = config_default[chainKey];\n    if (!contractData) {\n      throw new Error(`Unsupported chain: \"${chainKey}\"`);\n    }\n    const rpcProvider = new import_ethers4.ethers.JsonRpcProvider(contractData.rpcUrl);\n    existingContractsMap[chainKey] = Reclaim__factory.connect(contractData.address, rpcProvider);\n  }\n  return existingContractsMap[chainKey];\n}\n\n// src/utils/proofUtils.ts\nvar logger5 = logger_default.logger;\nfunction generateRequestedProof(provider) {\n  const providerParams = {};\n  provider.responseSelections.forEach(rs => rs.responseMatch.split(/{{(.*?)}}/).filter((_, i) => i % 2).forEach(param => providerParams[param] = \"\"));\n  const proof = {\n    url: provider.url,\n    parameters: providerParams\n  };\n  return proof;\n}\nfunction getFilledParameters(requestedProof) {\n  return Object.keys(requestedProof.parameters).reduce((acc, param) => {\n    if (requestedProof.parameters[param]) {\n      acc[param] = requestedProof.parameters[param];\n    }\n    return acc;\n  }, {});\n}\nfunction getShortenedUrl(url) {\n  return __async(this, null, function* () {\n    logger5.info(`Attempting to shorten URL: ${url}`);\n    try {\n      validateURL(url, \"getShortenedUrl\");\n      const response = yield fetch(`${BACKEND_BASE_URL}/api/sdk/shortener`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n          fullUrl: url\n        })\n      });\n      const res = yield response.json();\n      if (!response.ok) {\n        logger5.info(`Failed to shorten URL: ${url}, Response: ${JSON.stringify(res)}`);\n        return url;\n      }\n      const shortenedVerificationUrl = res.result.shortUrl;\n      return shortenedVerificationUrl;\n    } catch (err) {\n      logger5.info(`Error shortening URL: ${url}, Error: ${err}`);\n      return url;\n    }\n  });\n}\nfunction createLinkWithTemplateData(templateData) {\n  return __async(this, null, function* () {\n    let template = encodeURIComponent(JSON.stringify(templateData));\n    template = replaceAll(template, \"(\", \"%28\");\n    template = replaceAll(template, \")\", \"%29\");\n    const fullLink = `${constants.RECLAIM_SHARE_URL}${template}`;\n    try {\n      const shortenedLink = yield getShortenedUrl(fullLink);\n      return shortenedLink;\n    } catch (err) {\n      logger5.info(`Error creating link for sessionId: ${templateData.sessionId}, Error: ${err}`);\n      return fullLink;\n    }\n  });\n}\nfunction getWitnessesForClaim(epoch, identifier, timestampS) {\n  return __async(this, null, function* () {\n    const beacon = makeBeacon();\n    if (!beacon) {\n      logger5.info(\"No beacon available for getting witnesses\");\n      throw new Error(\"No beacon available\");\n    }\n    const state = yield beacon.getState(epoch);\n    const witnessList = fetchWitnessListForClaim(state, identifier, timestampS);\n    const witnesses = witnessList.map(w => w.id.toLowerCase());\n    return witnesses;\n  });\n}\nfunction recoverSignersOfSignedClaim({\n  claim,\n  signatures\n}) {\n  const dataStr = createSignDataForClaim(__spreadValues({}, claim));\n  const signers = signatures.map(signature => import_ethers5.ethers.verifyMessage(dataStr, import_ethers5.ethers.hexlify(signature)).toLowerCase());\n  return signers;\n}\nfunction assertValidSignedClaim(claim, expectedWitnessAddresses) {\n  const witnessAddresses = recoverSignersOfSignedClaim(claim);\n  const witnessesNotSeen = new Set(expectedWitnessAddresses);\n  for (const witness of witnessAddresses) {\n    if (witnessesNotSeen.has(witness)) {\n      witnessesNotSeen.delete(witness);\n    }\n  }\n  if (witnessesNotSeen.size > 0) {\n    const missingWitnesses = Array.from(witnessesNotSeen).join(\", \");\n    logger5.info(`Claim validation failed. Missing signatures from: ${missingWitnesses}`);\n    throw new ProofNotVerifiedError(`Missing signatures from ${missingWitnesses}`);\n  }\n}\n\n// src/Reclaim.ts\nvar logger6 = logger_default.logger;\nvar sdkVersion = require_package().version;\nfunction verifyProof(proofOrProofs) {\n  return __async(this, null, function* () {\n    var _a;\n    if (Array.isArray(proofOrProofs)) {\n      for (const proof2 of proofOrProofs) {\n        const isVerified = yield verifyProof(proof2);\n        if (!isVerified) {\n          return false;\n        }\n      }\n      return true;\n    }\n    const proof = proofOrProofs;\n    if (!proof.signatures.length) {\n      throw new SignatureNotFoundError(\"No signatures\");\n    }\n    try {\n      let witnesses = [];\n      if (proof.witnesses.length && ((_a = proof.witnesses[0]) == null ? void 0 : _a.url) === \"manual-verify\") {\n        witnesses.push(proof.witnesses[0].id);\n      } else {\n        witnesses = yield getWitnessesForClaim(proof.claimData.epoch, proof.identifier, proof.claimData.timestampS);\n      }\n      const calculatedIdentifier = getIdentifierFromClaimInfo({\n        parameters: JSON.parse((0, import_canonicalize2.default)(proof.claimData.parameters)),\n        provider: proof.claimData.provider,\n        context: proof.claimData.context\n      });\n      proof.identifier = replaceAll(proof.identifier, '\"', \"\");\n      if (calculatedIdentifier !== proof.identifier) {\n        throw new ProofNotVerifiedError(\"Identifier Mismatch\");\n      }\n      const signedClaim = {\n        claim: __spreadValues({}, proof.claimData),\n        signatures: proof.signatures.map(signature => {\n          return import_ethers6.ethers.getBytes(signature);\n        })\n      };\n      assertValidSignedClaim(signedClaim, witnesses);\n    } catch (e) {\n      logger6.info(`Error verifying proof: ${e instanceof Error ? e.message : String(e)}`);\n      return false;\n    }\n    return true;\n  });\n}\nfunction transformForOnchain(proof) {\n  const claimInfoBuilder = /* @__PURE__ */new Map([[\"context\", proof.claimData.context], [\"parameters\", proof.claimData.parameters], [\"provider\", proof.claimData.provider]]);\n  const claimInfo = Object.fromEntries(claimInfoBuilder);\n  const claimBuilder = /* @__PURE__ */new Map([[\"epoch\", proof.claimData.epoch], [\"identifier\", proof.claimData.identifier], [\"owner\", proof.claimData.owner], [\"timestampS\", proof.claimData.timestampS]]);\n  const signedClaim = {\n    claim: Object.fromEntries(claimBuilder),\n    signatures: proof.signatures\n  };\n  return {\n    claimInfo,\n    signedClaim\n  };\n}\nvar ReclaimProofRequest = class _ReclaimProofRequest {\n  // 30 seconds timeout, can be adjusted\n  // Private constructor\n  constructor(applicationId, providerId, options) {\n    this.context = {\n      contextAddress: \"0x0\",\n      contextMessage: \"sample context\"\n    };\n    this.intervals = /* @__PURE__ */new Map();\n    this.jsonProofResponse = false;\n    this.FAILURE_TIMEOUT = 3e4;\n    this.providerId = providerId;\n    this.timeStamp = Date.now().toString();\n    this.applicationId = applicationId;\n    this.sessionId = \"\";\n    if (options == null ? void 0 : options.log) {\n      logger_default.setLogLevel(\"info\");\n    } else {\n      logger_default.setLogLevel(\"silent\");\n    }\n    this.options = options;\n    this.sdkVersion = \"js-\" + sdkVersion;\n    logger6.info(`Initializing client with applicationId: ${this.applicationId}`);\n  }\n  // Static initialization methods\n  static init(applicationId, appSecret, providerId, options) {\n    return __async(this, null, function* () {\n      try {\n        validateFunctionParams([{\n          paramName: \"applicationId\",\n          input: applicationId,\n          isString: true\n        }, {\n          paramName: \"providerId\",\n          input: providerId,\n          isString: true\n        }, {\n          paramName: \"appSecret\",\n          input: appSecret,\n          isString: true\n        }], \"the constructor\");\n        if (options) {\n          if (options.acceptAiProviders) {\n            validateFunctionParams([{\n              paramName: \"acceptAiProviders\",\n              input: options.acceptAiProviders\n            }], \"the constructor\");\n          }\n          if (options.log) {\n            validateFunctionParams([{\n              paramName: \"log\",\n              input: options.log\n            }], \"the constructor\");\n          }\n          if (options.useAppClip) {\n            validateFunctionParams([{\n              paramName: \"useAppClip\",\n              input: options.useAppClip\n            }], \"the constructor\");\n          }\n          if (options.device) {\n            validateFunctionParams([{\n              paramName: \"device\",\n              input: options.device,\n              isString: true\n            }], \"the constructor\");\n          }\n        }\n        const proofRequestInstance = new _ReclaimProofRequest(applicationId, providerId, options);\n        const signature = yield proofRequestInstance.generateSignature(appSecret);\n        proofRequestInstance.setSignature(signature);\n        const data = yield initSession(providerId, applicationId, proofRequestInstance.timeStamp, signature);\n        proofRequestInstance.sessionId = data.sessionId;\n        yield proofRequestInstance.buildProofRequest(data.provider);\n        return proofRequestInstance;\n      } catch (error) {\n        logger6.info(\"Failed to initialize ReclaimProofRequest\", error);\n        throw new InitError(\"Failed to initialize ReclaimProofRequest\", error);\n      }\n    });\n  }\n  static fromJsonString(jsonString) {\n    return __async(this, null, function* () {\n      try {\n        const {\n          applicationId,\n          providerId,\n          sessionId,\n          context,\n          requestedProof,\n          signature,\n          redirectUrl,\n          timeStamp,\n          appCallbackUrl,\n          options,\n          sdkVersion: sdkVersion2,\n          jsonProofResponse\n        } = JSON.parse(jsonString);\n        validateFunctionParams([{\n          input: applicationId,\n          paramName: \"applicationId\",\n          isString: true\n        }, {\n          input: providerId,\n          paramName: \"providerId\",\n          isString: true\n        }, {\n          input: signature,\n          paramName: \"signature\",\n          isString: true\n        }, {\n          input: sessionId,\n          paramName: \"sessionId\",\n          isString: true\n        }, {\n          input: timeStamp,\n          paramName: \"timeStamp\",\n          isString: true\n        }, {\n          input: sdkVersion2,\n          paramName: \"sdkVersion\",\n          isString: true\n        }], \"fromJsonString\");\n        validateRequestedProof(requestedProof);\n        if (redirectUrl) {\n          validateURL(redirectUrl, \"fromJsonString\");\n        }\n        if (appCallbackUrl) {\n          validateURL(appCallbackUrl, \"fromJsonString\");\n        }\n        if (context) {\n          validateContext(context);\n        }\n        if (jsonProofResponse !== void 0) {\n          validateFunctionParams([{\n            input: jsonProofResponse,\n            paramName: \"jsonProofResponse\"\n          }], \"fromJsonString\");\n        }\n        const proofRequestInstance = new _ReclaimProofRequest(applicationId, providerId, options);\n        proofRequestInstance.sessionId = sessionId;\n        proofRequestInstance.context = context;\n        proofRequestInstance.requestedProof = requestedProof;\n        proofRequestInstance.appCallbackUrl = appCallbackUrl;\n        proofRequestInstance.redirectUrl = redirectUrl;\n        proofRequestInstance.timeStamp = timeStamp;\n        proofRequestInstance.signature = signature;\n        proofRequestInstance.sdkVersion = sdkVersion2;\n        return proofRequestInstance;\n      } catch (error) {\n        logger6.info(\"Failed to parse JSON string in fromJsonString:\", error);\n        throw new InvalidParamError(\"Invalid JSON string provided to fromJsonString\");\n      }\n    });\n  }\n  // Setter methods\n  setAppCallbackUrl(url, jsonProofResponse) {\n    validateURL(url, \"setAppCallbackUrl\");\n    this.appCallbackUrl = url;\n    this.jsonProofResponse = jsonProofResponse != null ? jsonProofResponse : false;\n  }\n  setRedirectUrl(url) {\n    validateURL(url, \"setRedirectUrl\");\n    this.redirectUrl = url;\n  }\n  addContext(address, message) {\n    try {\n      validateFunctionParams([{\n        input: address,\n        paramName: \"address\",\n        isString: true\n      }, {\n        input: message,\n        paramName: \"message\",\n        isString: true\n      }], \"addContext\");\n      this.context = {\n        contextAddress: address,\n        contextMessage: message\n      };\n    } catch (error) {\n      logger6.info(\"Error adding context\", error);\n      throw new AddContextError(\"Error adding context\", error);\n    }\n  }\n  setParams(params) {\n    try {\n      const requestedProof = this.getRequestedProof();\n      if (!requestedProof || !this.requestedProof) {\n        throw new BuildProofRequestError(\"Requested proof is not present.\");\n      }\n      const currentParams = this.availableParams();\n      if (!currentParams) {\n        throw new NoProviderParamsError(\"No params present in the provider config.\");\n      }\n      const paramsToSet = Object.keys(params);\n      for (const param of paramsToSet) {\n        if (!currentParams.includes(param)) {\n          throw new InvalidParamError(`Cannot set parameter ${param} for provider ${this.providerId}. Available parameters: ${currentParams}`);\n        }\n      }\n      this.requestedProof.parameters = __spreadValues(__spreadValues({}, requestedProof.parameters), params);\n    } catch (error) {\n      logger6.info(\"Error Setting Params:\", error);\n      throw new SetParamsError(\"Error setting params\", error);\n    }\n  }\n  // Getter methods\n  getAppCallbackUrl() {\n    try {\n      validateFunctionParams([{\n        input: this.sessionId,\n        paramName: \"sessionId\",\n        isString: true\n      }], \"getAppCallbackUrl\");\n      return this.appCallbackUrl || `${constants.DEFAULT_RECLAIM_CALLBACK_URL}${this.sessionId}`;\n    } catch (error) {\n      logger6.info(\"Error getting app callback url\", error);\n      throw new GetAppCallbackUrlError(\"Error getting app callback url\", error);\n    }\n  }\n  getStatusUrl() {\n    try {\n      validateFunctionParams([{\n        input: this.sessionId,\n        paramName: \"sessionId\",\n        isString: true\n      }], \"getStatusUrl\");\n      return `${constants.DEFAULT_RECLAIM_STATUS_URL}${this.sessionId}`;\n    } catch (error) {\n      logger6.info(\"Error fetching Status Url\", error);\n      throw new GetStatusUrlError(\"Error fetching status url\", error);\n    }\n  }\n  // Private helper methods\n  setSignature(signature) {\n    try {\n      validateFunctionParams([{\n        input: signature,\n        paramName: \"signature\",\n        isString: true\n      }], \"setSignature\");\n      this.signature = signature;\n      logger6.info(`Signature set successfully for applicationId: ${this.applicationId}`);\n    } catch (error) {\n      logger6.info(\"Error setting signature\", error);\n      throw new SetSignatureError(\"Error setting signature\", error);\n    }\n  }\n  generateSignature(applicationSecret) {\n    return __async(this, null, function* () {\n      try {\n        const wallet = new import_ethers6.ethers.Wallet(applicationSecret);\n        const canonicalData = (0, import_canonicalize2.default)({\n          providerId: this.providerId,\n          timestamp: this.timeStamp\n        });\n        if (!canonicalData) {\n          throw new SignatureGeneratingError(\"Failed to canonicalize data for signing.\");\n        }\n        const messageHash = import_ethers6.ethers.keccak256(new TextEncoder().encode(canonicalData));\n        return yield wallet.signMessage(import_ethers6.ethers.getBytes(messageHash));\n      } catch (err) {\n        logger6.info(`Error generating proof request for applicationId: ${this.applicationId}, providerId: ${this.providerId}, signature: ${this.signature}, timeStamp: ${this.timeStamp}`, err);\n        throw new SignatureGeneratingError(`Error generating signature for applicationSecret: ${applicationSecret}`);\n      }\n    });\n  }\n  buildProofRequest(provider) {\n    return __async(this, null, function* () {\n      try {\n        this.requestedProof = generateRequestedProof(provider);\n        return this.requestedProof;\n      } catch (err) {\n        logger6.info(err instanceof Error ? err.message : String(err));\n        throw new BuildProofRequestError(\"Something went wrong while generating proof request\", err);\n      }\n    });\n  }\n  getRequestedProof() {\n    if (!this.requestedProof) {\n      throw new BuildProofRequestError(\"RequestedProof is not present in the instance.\");\n    }\n    return this.requestedProof;\n  }\n  availableParams() {\n    try {\n      const requestedProofs = this.getRequestedProof();\n      let availableParamsStore = Object.keys(requestedProofs.parameters);\n      availableParamsStore = availableParamsStore.concat(requestedProofs.url.split(/{{(.*?)}}/).filter((_, i) => i % 2));\n      return [...new Set(availableParamsStore)];\n    } catch (error) {\n      logger6.info(\"Error fetching available params\", error);\n      throw new AvailableParamsError(\"Error fetching available params\", error);\n    }\n  }\n  clearInterval() {\n    if (this.sessionId && this.intervals.has(this.sessionId)) {\n      clearInterval(this.intervals.get(this.sessionId));\n      this.intervals.delete(this.sessionId);\n    }\n  }\n  // Public methods\n  toJsonString(options) {\n    return JSON.stringify({\n      applicationId: this.applicationId,\n      providerId: this.providerId,\n      sessionId: this.sessionId,\n      context: this.context,\n      requestedProof: this.requestedProof,\n      appCallbackUrl: this.appCallbackUrl,\n      signature: this.signature,\n      redirectUrl: this.redirectUrl,\n      timeStamp: this.timeStamp,\n      options: this.options,\n      sdkVersion: this.sdkVersion,\n      jsonProofResponse: this.jsonProofResponse\n    });\n  }\n  getRequestUrl() {\n    return __async(this, null, function* () {\n      var _a, _b, _c, _d, _e;\n      logger6.info(\"Creating Request Url\");\n      if (!this.signature) {\n        throw new SignatureNotFoundError(\"Signature is not set.\");\n      }\n      try {\n        const requestedProof = this.getRequestedProof();\n        validateSignature(this.providerId, this.signature, this.applicationId, this.timeStamp);\n        const templateData = {\n          sessionId: this.sessionId,\n          providerId: this.providerId,\n          applicationId: this.applicationId,\n          signature: this.signature,\n          timestamp: this.timeStamp,\n          callbackUrl: this.getAppCallbackUrl(),\n          context: JSON.stringify(this.context),\n          parameters: getFilledParameters(requestedProof),\n          redirectUrl: (_a = this.redirectUrl) != null ? _a : \"\",\n          acceptAiProviders: (_c = (_b = this.options) == null ? void 0 : _b.acceptAiProviders) != null ? _c : false,\n          sdkVersion: this.sdkVersion,\n          jsonProofResponse: this.jsonProofResponse\n        };\n        yield updateSession(this.sessionId, \"SESSION_STARTED\" /* SESSION_STARTED */);\n        if ((_d = this.options) == null ? void 0 : _d.useAppClip) {\n          let template = encodeURIComponent(JSON.stringify(templateData));\n          template = replaceAll(template, \"(\", \"%28\");\n          template = replaceAll(template, \")\", \"%29\");\n          const isIos = ((_e = this.options) == null ? void 0 : _e.device) === \"ios\";\n          if (!isIos) {\n            const instantAppUrl = `https://share.reclaimprotocol.org/verify/?template=${template}`;\n            logger6.info(\"Instant App Url created successfully: \" + instantAppUrl);\n            return instantAppUrl;\n          } else {\n            const appClipUrl = `https://appclip.apple.com/id?p=org.reclaimprotocol.app.clip&template=${template}`;\n            logger6.info(\"App Clip Url created successfully: \" + appClipUrl);\n            return appClipUrl;\n          }\n        } else {\n          const link = yield createLinkWithTemplateData(templateData);\n          logger6.info(\"Request Url created successfully: \" + link);\n          return link;\n        }\n      } catch (error) {\n        logger6.info(\"Error creating Request Url:\", error);\n        throw error;\n      }\n    });\n  }\n  startSession(_0) {\n    return __async(this, arguments, function* ({\n      onSuccess,\n      onError\n    }) {\n      if (!this.sessionId) {\n        const message = \"Session can't be started due to undefined value of sessionId\";\n        logger6.info(message);\n        throw new SessionNotStartedError(message);\n      }\n      logger6.info(\"Starting session\");\n      const interval = setInterval(() => __async(this, null, function* () {\n        try {\n          const statusUrlResponse = yield fetchStatusUrl(this.sessionId);\n          if (!statusUrlResponse.session) return;\n          if (statusUrlResponse.session.statusV2 !== \"PROOF_GENERATION_FAILED\" /* PROOF_GENERATION_FAILED */) {\n            this.lastFailureTime = void 0;\n          }\n          if (statusUrlResponse.session.statusV2 === \"PROOF_GENERATION_FAILED\" /* PROOF_GENERATION_FAILED */) {\n            const currentTime = Date.now();\n            if (!this.lastFailureTime) {\n              this.lastFailureTime = currentTime;\n            } else if (currentTime - this.lastFailureTime >= this.FAILURE_TIMEOUT) {\n              throw new ProviderFailedError(\"Proof generation failed - timeout reached\");\n            }\n            return;\n          }\n          const isDefaultCallbackUrl = this.getAppCallbackUrl() === `${constants.DEFAULT_RECLAIM_CALLBACK_URL}${this.sessionId}`;\n          if (isDefaultCallbackUrl) {\n            if (statusUrlResponse.session.proofs && statusUrlResponse.session.proofs.length > 0) {\n              const proofs = statusUrlResponse.session.proofs;\n              const verified = yield verifyProof(proofs);\n              if (!verified) {\n                logger6.info(`Proofs not verified: ${JSON.stringify(proofs)}`);\n                throw new ProofNotVerifiedError();\n              }\n              if (proofs.length === 1) {\n                onSuccess(proofs[0]);\n              } else {\n                onSuccess(proofs);\n              }\n              this.clearInterval();\n            }\n          } else {\n            if (statusUrlResponse.session.statusV2 === \"PROOF_SUBMISSION_FAILED\" /* PROOF_SUBMISSION_FAILED */) {\n              throw new ProofSubmissionFailedError();\n            }\n            if (statusUrlResponse.session.statusV2 === \"PROOF_SUBMITTED\" /* PROOF_SUBMITTED */) {\n              if (onSuccess) {\n                onSuccess(\"Proof submitted successfully to the custom callback url\");\n              }\n              this.clearInterval();\n            }\n          }\n        } catch (e) {\n          if (onError) {\n            onError(e);\n          }\n          this.clearInterval();\n        }\n      }), 3e3);\n      this.intervals.set(this.sessionId, interval);\n      scheduleIntervalEndingTask(this.sessionId, this.intervals, onError);\n    });\n  }\n};\n// Annotate the CommonJS export names for ESM import in node:\n0 && (module.exports = {\n  ReclaimProofRequest,\n  transformForOnchain,\n  verifyProof\n});","map":{"version":3,"names":["require_package","__commonJS","package.json","exports2","module2","exports","name","version","description","main","types","keywords","files","tsup","entry","splitting","sourcemap","clean","scripts","build","release","test","commitlint","repository","type","url","author","license","bugs","homepage","publishConfig","registry","access","git","commitMessage","tagName","npm","publish","tag","github","plugins","preset","devDependencies","typescript","dependencies","canonicalize","ethers","qs","uuid","index_exports","__export","ReclaimProofRequest","transformForOnchain","verifyProof","module","__toCommonJS","import_ethers","require","fetchWitnessListForClaim","witnesses","witnessesRequiredForClaim","epoch","params","timestampS","identifier","getIdentifierFromClaimInfo","completeInput","toString","join","completeHashStr","keccak256","strToUint8Array","completeHash","getBytes","completeHashView","uint8ArrayToDataView","witnessesLeft","selectedWitnesses","byteOffset","i","randomSeed","getUint32","witnessIndex","length","witness","push","pop","info","str","provider","parameters","context","toLowerCase","TextEncoder","encode","arr","DataView","buffer","byteLength","createSignDataForClaim","data","lines","owner","import_ethers6","import_canonicalize2","__toESM","createErrorClass","Error","constructor","message","innerError","stack","TimeoutError","ProofNotVerifiedError","SessionNotStartedError","ProviderNotFoundError","BuildProofRequestError","SignatureGeneratingError","SignatureNotFoundError","InvalidSignatureError","UpdateSessionError","InitSessionError","ProviderFailedError","InvalidParamError","ApplicationError","InitError","AvailableParamsError","BackendServerError","GetStatusUrlError","NoProviderParamsError","SetParamsError","AddContextError","SetSignatureError","GetAppCallbackUrlError","GetRequestUrlError","StatusUrlError","ProofSubmissionFailedError","SimpleLogger","level","setLevel","shouldLog","messageLevel","levels","indexOf","log","args","logFunction","getLogFunction","console","toUpperCase","error","warn","logger","setLogLevel","logger_default","logger2","escapeRegExp","string","replace","replaceAll","find","RegExp","scheduleIntervalEndingTask","sessionId","intervals","onFailureCallback","timeout","setTimeout","has","clearInterval","get","delete","BACKEND_BASE_URL","constants","DEFAULT_RECLAIM_CALLBACK_URL","DEFAULT_RECLAIM_STATUS_URL","RECLAIM_SHARE_URL","import_ethers2","import_canonicalize","logger3","validateFunctionParams","functionName","forEach","input","paramName","isString","trim","validateURL","URL","e","validateSignature","providerId","signature","applicationId","timestamp","default","messageHash","appId","verifyMessage","hexlify","getAddress","err","validateRequestedProof","requestedProof","validateContext","contextAddress","contextMessage","logger4","initSession","__async","response","fetch","method","headers","body","JSON","stringify","res","json","ok","updateSession","status","errorMessage","fetchStatusUrl","import_ethers5","import_ethers3","_abi","anonymous","inputs","indexed","internalType","components","outputs","stateMutability","Reclaim__factory","connect","address","signerOrProvider","Contract","abi","config_default","chainName","rpcUrl","import_ethers4","DEFAULT_CHAIN_ID","makeBeacon","chainId","contract","getContract","_a","makeBeaconCacheable","getState","epochId","fetchEpoch","id","map","w","addr","host","minimumWitnessesForClaimCreation","nextEpochTimestampS","timestampEnd","beacon","cache","__spreadProps","__spreadValues","state","key","existingContractsMap","chainKey","contractData","rpcProvider","JsonRpcProvider","logger5","generateRequestedProof","providerParams","responseSelections","rs","responseMatch","split","filter","_","param","proof","getFilledParameters","Object","keys","reduce","acc","getShortenedUrl","fullUrl","shortenedVerificationUrl","result","shortUrl","createLinkWithTemplateData","templateData","template","encodeURIComponent","fullLink","shortenedLink","getWitnessesForClaim","witnessList","recoverSignersOfSignedClaim","claim","signatures","dataStr","signers","assertValidSignedClaim","expectedWitnessAddresses","witnessAddresses","witnessesNotSeen","Set","size","missingWitnesses","Array","from","logger6","sdkVersion","proofOrProofs","isArray","proof2","isVerified","claimData","calculatedIdentifier","parse","signedClaim","String","claimInfoBuilder","Map","claimInfo","fromEntries","claimBuilder","_ReclaimProofRequest","options","jsonProofResponse","FAILURE_TIMEOUT","timeStamp","Date","now","init","appSecret","acceptAiProviders","useAppClip","device","proofRequestInstance","generateSignature","setSignature","buildProofRequest","fromJsonString","jsonString","redirectUrl","appCallbackUrl","sdkVersion2","setAppCallbackUrl","setRedirectUrl","addContext","setParams","getRequestedProof","currentParams","availableParams","paramsToSet","includes","getAppCallbackUrl","getStatusUrl","applicationSecret","wallet","Wallet","canonicalData","signMessage","requestedProofs","availableParamsStore","concat","toJsonString","getRequestUrl","_b","_c","_d","_e","callbackUrl","isIos","instantAppUrl","appClipUrl","link","startSession","_0","arguments","onSuccess","onError","interval","setInterval","statusUrlResponse","session","statusV2","lastFailureTime","currentTime","isDefaultCallbackUrl","proofs","verified","set"],"sources":["../package.json","../src/index.ts","../src/witness.ts","../src/Reclaim.ts","../src/utils/errors.ts","../src/utils/logger.ts","../src/utils/helper.ts","../src/utils/constants.ts","../src/utils/validationUtils.ts","../src/utils/sessionUtils.ts","../src/utils/proofUtils.ts","../src/contract-types/contracts/factories/Reclaim__factory.ts","../src/contract-types/config.json","../src/smart-contract.ts"],"sourcesContent":["{\n  \"name\": \"@reclaimprotocol/js-sdk\",\n  \"version\": \"2.2.0\",\n  \"description\": \"Designed to request proofs from the Reclaim protocol and manage the flow of claims and witness interactions.\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"keywords\": [\n    \"reclaim\",\n    \"protocol\",\n    \"blockchain\",\n    \"proof\",\n    \"verification\",\n    \"identity\",\n    \"claims\",\n    \"witness\",\n    \"sdk\",\n    \"javascript\",\n    \"typescript\",\n    \"decentralized\",\n    \"web3\"\n  ],\n  \"files\": [\n    \"dist\"\n  ],\n  \"tsup\": {\n    \"entry\": [\n      \"src/index.ts\"\n    ],\n    \"splitting\": false,\n    \"sourcemap\": true,\n    \"clean\": true\n  },\n  \"scripts\": {\n    \"build\": \"sh scripts/build.sh\",\n    \"release\": \"release-it\",\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"commitlint\": \"commitlint --edit\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/reclaimprotocol/reclaim-js-sdk\"\n  },\n  \"author\": \"ali <ali@creatoros.co>\",\n  \"license\": \"See License in <https://github.com/reclaimprotocol/.github/blob/main/LICENSE>\",\n  \"bugs\": {\n    \"url\": \"https://github.com/reclaimprotocol/reclaim-js-sdk/issues\"\n  },\n  \"homepage\": \"https://github.com/reclaimprotocol/reclaim-js-sdk/\",\n  \"publishConfig\": {\n    \"registry\": \"https://registry.npmjs.org/\",\n    \"access\": \"public\"\n  },\n  \"release-it\": {\n    \"git\": {\n      \"commitMessage\": \"chore: release ${version}\",\n      \"tagName\": \"v${version}\"\n    },\n    \"npm\": {\n      \"publish\": true,\n      \"tag\": \"latest\"\n    },\n    \"github\": {\n      \"release\": true\n    },\n    \"plugins\": {\n      \"@release-it/conventional-changelog\": {\n        \"preset\": \"angular\"\n      }\n    }\n  },\n  \"devDependencies\": {\n    \"@bconnorwhite/bob\": \"^2.9.5\",\n    \"@commitlint/cli\": \"^17.7.1\",\n    \"@commitlint/config-conventional\": \"^17.7.0\",\n    \"@release-it/conventional-changelog\": \"^5.0.0\",\n    \"@types/qs\": \"^6.9.11\",\n    \"@types/url-parse\": \"^1.4.11\",\n    \"@types/uuid\": \"^9.0.7\",\n    \"release-it\": \"^15.0.0\",\n    \"tsup\": \"^8.0.1\",\n    \"typescript\": \"^5.3.3\"\n  },\n  \"dependencies\": {\n    \"canonicalize\": \"^2.0.0\",\n    \"ethers\": \"^6.9.1\",\n    \"qs\": \"^6.11.2\",\n    \"url-parse\": \"^1.5.10\",\n    \"uuid\": \"^9.0.1\"\n  }\n}\n","export * from './Reclaim';\nexport * from './utils/interfaces';","import { ethers } from 'ethers';\nimport type { WitnessData } from './utils/interfaces';\nimport type { ClaimID, ClaimInfo, CompleteClaimData } from './utils/types';\n\ntype BeaconState = {\n  witnesses: WitnessData[];\n  epoch: number;\n  witnessesRequiredForClaim: number;\n  nextEpochTimestampS: number;\n};\n\nexport function fetchWitnessListForClaim(\n  { witnesses, witnessesRequiredForClaim, epoch }: BeaconState,\n  params: string | ClaimInfo,\n  timestampS: number\n): WitnessData[] {\n  const identifier: ClaimID =\n    typeof params === 'string' ? params : getIdentifierFromClaimInfo(params);\n  const completeInput: string = [\n    identifier,\n    epoch.toString(),\n    witnessesRequiredForClaim.toString(),\n    timestampS.toString(),\n  ].join('\\n');\n  const completeHashStr: string = ethers.keccak256(strToUint8Array(completeInput));\n  const completeHash: Uint8Array = ethers.getBytes(completeHashStr);\n  const completeHashView: DataView = uint8ArrayToDataView(completeHash);\n  const witnessesLeft: WitnessData[] = [...witnesses];\n  const selectedWitnesses: WitnessData[] = [];\n  let byteOffset: number = 0;\n  for (let i = 0; i < witnessesRequiredForClaim; i++) {\n    const randomSeed: number = completeHashView.getUint32(byteOffset);\n    const witnessIndex: number = randomSeed % witnessesLeft.length;\n    const witness: WitnessData = witnessesLeft[witnessIndex];\n    selectedWitnesses.push(witness);\n\n    witnessesLeft[witnessIndex] = witnessesLeft[witnessesLeft.length - 1];\n    witnessesLeft.pop();\n    byteOffset = (byteOffset + 4) % completeHash.length;\n  }\n\n  return selectedWitnesses;\n}\n\nexport function getIdentifierFromClaimInfo(info: ClaimInfo): ClaimID {\n  const str: string = `${info.provider}\\n${info.parameters}\\n${info.context || ''}`;\n  return ethers.keccak256(strToUint8Array(str)).toLowerCase();\n}\n\nexport function strToUint8Array(str: string): Uint8Array {\n  return new TextEncoder().encode(str);\n}\n\nexport function uint8ArrayToDataView(arr: Uint8Array): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\nexport function createSignDataForClaim(data: CompleteClaimData): string {\n  const identifier: ClaimID =\n    'identifier' in data ? data.identifier : getIdentifierFromClaimInfo(data);\n  const lines: string[] = [\n    identifier,\n    data.owner.toLowerCase(),\n    data.timestampS.toString(),\n    data.epoch.toString(),\n  ];\n\n  return lines.join('\\n');\n}\n","import type { Proof, RequestedProof, Context, ProviderData } from './utils/interfaces'\nimport { getIdentifierFromClaimInfo } from './witness'\nimport type {\n    SignedClaim,\n    ProofRequestOptions,\n    StartSessionParams,\n    ProofPropertiesJSON,\n    TemplateData\n} from './utils/types'\nimport { SessionStatus } from './utils/types'\nimport { ethers } from 'ethers'\nimport canonicalize from 'canonicalize'\nimport {\n    replaceAll,\n    scheduleIntervalEndingTask\n} from './utils/helper'\nimport { constants } from './utils/constants'\nimport {\n    AddContextError,\n    AvailableParamsError,\n    BuildProofRequestError,\n    GetAppCallbackUrlError,\n    GetStatusUrlError,\n    InitError,\n    InvalidParamError,\n    NoProviderParamsError,\n    ProofNotVerifiedError,\n    ProofSubmissionFailedError,\n    ProviderFailedError,\n    SessionNotStartedError,\n    SetParamsError,\n    SetSignatureError,\n    SignatureGeneratingError,\n    SignatureNotFoundError\n} from './utils/errors'\nimport { validateContext, validateFunctionParams, validateRequestedProof, validateSignature, validateURL } from './utils/validationUtils'\nimport { fetchStatusUrl, initSession, updateSession } from './utils/sessionUtils'\nimport { assertValidSignedClaim, createLinkWithTemplateData, generateRequestedProof, getFilledParameters, getWitnessesForClaim } from './utils/proofUtils'\nimport loggerModule from './utils/logger';\nconst logger = loggerModule.logger\n\nconst sdkVersion = require('../package.json').version;\n\n// Implementation\nexport async function verifyProof(proofOrProofs: Proof | Proof[]): Promise<boolean> {\n    // If input is an array of proofs\n    if (Array.isArray(proofOrProofs)) {\n        for (const proof of proofOrProofs) {\n            const isVerified = await verifyProof(proof);\n            if (!isVerified) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // Single proof verification logic\n    const proof = proofOrProofs;\n    if (!proof.signatures.length) {\n        throw new SignatureNotFoundError('No signatures')\n    }\n\n    try {\n        // check if witness array exist and first element is manual-verify\n        let witnesses = []\n        if (proof.witnesses.length && proof.witnesses[0]?.url === 'manual-verify') {\n            witnesses.push(proof.witnesses[0].id)\n        } else {\n            witnesses = await getWitnessesForClaim(\n                proof.claimData.epoch,\n                proof.identifier,\n                proof.claimData.timestampS\n            )\n        }\n        // then hash the claim info with the encoded ctx to get the identifier\n        const calculatedIdentifier = getIdentifierFromClaimInfo({\n            parameters: JSON.parse(\n                canonicalize(proof.claimData.parameters) as string\n            ),\n            provider: proof.claimData.provider,\n            context: proof.claimData.context\n        })\n        proof.identifier = replaceAll(proof.identifier, '\"', '')\n        // check if the identifier matches the one in the proof\n        if (calculatedIdentifier !== proof.identifier) {\n            throw new ProofNotVerifiedError('Identifier Mismatch')\n        }\n\n        const signedClaim: SignedClaim = {\n            claim: {\n                ...proof.claimData\n            },\n            signatures: proof.signatures.map(signature => {\n                return ethers.getBytes(signature)\n            })\n        }\n\n        assertValidSignedClaim(signedClaim, witnesses)\n    } catch (e: Error | unknown) {\n        logger.info(`Error verifying proof: ${e instanceof Error ? e.message : String(e)}`)\n        return false\n    }\n\n    return true\n}\n\nexport function transformForOnchain(proof: Proof): { claimInfo: any, signedClaim: any } {\n    const claimInfoBuilder = new Map([\n        ['context', proof.claimData.context],\n        ['parameters', proof.claimData.parameters],\n        ['provider', proof.claimData.provider],\n    ]);\n    const claimInfo = Object.fromEntries(claimInfoBuilder);\n    const claimBuilder = new Map<string, number | string>([\n        ['epoch', proof.claimData.epoch],\n        ['identifier', proof.claimData.identifier],\n        ['owner', proof.claimData.owner],\n        ['timestampS', proof.claimData.timestampS],\n    ]);\n    const signedClaim = {\n        claim: Object.fromEntries(claimBuilder),\n        signatures: proof.signatures,\n    };\n    return { claimInfo, signedClaim };\n}\n\nexport class ReclaimProofRequest {\n    // Private class properties\n    private applicationId: string;\n    private signature?: string;\n    private appCallbackUrl?: string;\n    private sessionId: string;\n    private options?: ProofRequestOptions;\n    private context: Context = { contextAddress: '0x0', contextMessage: 'sample context' };\n    private requestedProof?: RequestedProof;\n    private providerId: string;\n    private redirectUrl?: string;\n    private intervals: Map<string, NodeJS.Timer> = new Map();\n    private timeStamp: string;\n    private sdkVersion: string;\n    private jsonProofResponse: boolean = false;\n    private lastFailureTime?: number;\n    private readonly FAILURE_TIMEOUT = 30000; // 30 seconds timeout, can be adjusted\n\n    // Private constructor\n    private constructor(applicationId: string, providerId: string, options?: ProofRequestOptions) {\n        this.providerId = providerId;\n        this.timeStamp = Date.now().toString();\n        this.applicationId = applicationId;\n        this.sessionId = \"\";\n        if (options?.log) {\n            loggerModule.setLogLevel('info');\n        } else {\n            loggerModule.setLogLevel('silent');\n        }\n        this.options = options;\n        // Fetch sdk version from package.json\n        this.sdkVersion = 'js-' + sdkVersion;\n        logger.info(`Initializing client with applicationId: ${this.applicationId}`);\n    }\n\n    // Static initialization methods\n    static async init(applicationId: string, appSecret: string, providerId: string, options?: ProofRequestOptions): Promise<ReclaimProofRequest> {\n        try {\n            validateFunctionParams([\n                { paramName: 'applicationId', input: applicationId, isString: true },\n                { paramName: 'providerId', input: providerId, isString: true },\n                { paramName: 'appSecret', input: appSecret, isString: true }\n            ], 'the constructor')\n\n            // check if options is provided and validate each property of options\n            if (options) {\n                if (options.acceptAiProviders) {\n                    validateFunctionParams([\n                        { paramName: 'acceptAiProviders', input: options.acceptAiProviders }\n                    ], 'the constructor')\n                }\n                if (options.log) {\n                    validateFunctionParams([\n                        { paramName: 'log', input: options.log }\n                    ], 'the constructor')\n                }\n                if (options.useAppClip) {\n                    validateFunctionParams([\n                        { paramName: 'useAppClip', input: options.useAppClip }\n                    ], 'the constructor')\n                }\n                if (options.device) {\n                    validateFunctionParams([\n                        { paramName: 'device', input: options.device, isString: true }\n                    ], 'the constructor')\n                }\n\n            }\n\n            const proofRequestInstance = new ReclaimProofRequest(applicationId, providerId, options)\n\n            const signature = await proofRequestInstance.generateSignature(appSecret)\n            proofRequestInstance.setSignature(signature)\n\n            const data = await initSession(providerId, applicationId, proofRequestInstance.timeStamp, signature);\n            proofRequestInstance.sessionId = data.sessionId\n\n            await proofRequestInstance.buildProofRequest(data.provider)\n\n            return proofRequestInstance\n        } catch (error) {\n            logger.info('Failed to initialize ReclaimProofRequest', error as Error);\n            throw new InitError('Failed to initialize ReclaimProofRequest', error as Error)\n        }\n    }\n\n    static async fromJsonString(jsonString: string): Promise<ReclaimProofRequest> {\n        try {\n            const {\n                applicationId,\n                providerId,\n                sessionId,\n                context,\n                requestedProof,\n                signature,\n                redirectUrl,\n                timeStamp,\n                appCallbackUrl,\n                options,\n                sdkVersion,\n                jsonProofResponse\n            }: ProofPropertiesJSON = JSON.parse(jsonString)\n\n            validateFunctionParams([\n                { input: applicationId, paramName: 'applicationId', isString: true },\n                { input: providerId, paramName: 'providerId', isString: true },\n                { input: signature, paramName: 'signature', isString: true },\n                { input: sessionId, paramName: 'sessionId', isString: true },\n                { input: timeStamp, paramName: 'timeStamp', isString: true },\n                { input: sdkVersion, paramName: 'sdkVersion', isString: true },\n            ], 'fromJsonString');\n\n            validateRequestedProof(requestedProof);\n\n            if (redirectUrl) {\n                validateURL(redirectUrl, 'fromJsonString');\n            }\n\n            if (appCallbackUrl) {\n                validateURL(appCallbackUrl, 'fromJsonString');\n            }\n\n            if (context) {\n                validateContext(context);\n            }\n\n            if (jsonProofResponse !== undefined) {\n                validateFunctionParams([\n                    { input: jsonProofResponse, paramName: 'jsonProofResponse' }\n                ], 'fromJsonString');\n            }\n\n            const proofRequestInstance = new ReclaimProofRequest(applicationId, providerId, options);\n            proofRequestInstance.sessionId = sessionId;\n            proofRequestInstance.context = context;\n            proofRequestInstance.requestedProof = requestedProof\n            proofRequestInstance.appCallbackUrl = appCallbackUrl\n            proofRequestInstance.redirectUrl = redirectUrl\n            proofRequestInstance.timeStamp = timeStamp\n            proofRequestInstance.signature = signature\n            proofRequestInstance.sdkVersion = sdkVersion;\n            return proofRequestInstance\n        } catch (error) {\n            logger.info('Failed to parse JSON string in fromJsonString:', error);\n            throw new InvalidParamError('Invalid JSON string provided to fromJsonString');\n        }\n    }\n\n    // Setter methods\n    setAppCallbackUrl(url: string, jsonProofResponse?: boolean): void {\n        validateURL(url, 'setAppCallbackUrl')\n        this.appCallbackUrl = url\n        this.jsonProofResponse = jsonProofResponse ?? false\n    }\n\n    setRedirectUrl(url: string): void {\n        validateURL(url, 'setRedirectUrl');\n        this.redirectUrl = url;\n    }\n\n    addContext(address: string, message: string): void {\n        try {\n            validateFunctionParams([\n                { input: address, paramName: 'address', isString: true },\n                { input: message, paramName: 'message', isString: true }\n            ], 'addContext');\n            this.context = { contextAddress: address, contextMessage: message };\n        } catch (error) {\n            logger.info(\"Error adding context\", error)\n            throw new AddContextError(\"Error adding context\", error as Error)\n        }\n    }\n\n    setParams(params: { [key: string]: string }): void {\n        try {\n            const requestedProof = this.getRequestedProof();\n            if (!requestedProof || !this.requestedProof) {\n                throw new BuildProofRequestError('Requested proof is not present.');\n            }\n\n            const currentParams = this.availableParams()\n            if (!currentParams) {\n                throw new NoProviderParamsError('No params present in the provider config.');\n            }\n\n            const paramsToSet = Object.keys(params)\n            for (const param of paramsToSet) {\n                if (!currentParams.includes(param)) {\n                    throw new InvalidParamError(\n                        `Cannot set parameter ${param} for provider ${this.providerId}. Available parameters: ${currentParams}`\n                    );\n                }\n            }\n            this.requestedProof.parameters = { ...requestedProof.parameters, ...params }\n        } catch (error) {\n            logger.info('Error Setting Params:', error);\n            throw new SetParamsError(\"Error setting params\", error as Error)\n        }\n    }\n\n    // Getter methods\n    getAppCallbackUrl(): string {\n        try {\n            validateFunctionParams([{ input: this.sessionId, paramName: 'sessionId', isString: true }], 'getAppCallbackUrl');\n            return this.appCallbackUrl || `${constants.DEFAULT_RECLAIM_CALLBACK_URL}${this.sessionId}`\n        } catch (error) {\n            logger.info(\"Error getting app callback url\", error)\n            throw new GetAppCallbackUrlError(\"Error getting app callback url\", error as Error)\n        }\n    }\n\n    getStatusUrl(): string {\n        try {\n            validateFunctionParams([{ input: this.sessionId, paramName: 'sessionId', isString: true }], 'getStatusUrl');\n            return `${constants.DEFAULT_RECLAIM_STATUS_URL}${this.sessionId}`\n        } catch (error) {\n            logger.info(\"Error fetching Status Url\", error)\n            throw new GetStatusUrlError(\"Error fetching status url\", error as Error)\n        }\n    }\n\n    // Private helper methods\n    private setSignature(signature: string): void {\n        try {\n            validateFunctionParams([{ input: signature, paramName: 'signature', isString: true }], 'setSignature');\n            this.signature = signature;\n            logger.info(`Signature set successfully for applicationId: ${this.applicationId}`);\n        } catch (error) {\n            logger.info(\"Error setting signature\", error)\n            throw new SetSignatureError(\"Error setting signature\", error as Error)\n        }\n    }\n\n    private async generateSignature(applicationSecret: string): Promise<string> {\n        try {\n            const wallet = new ethers.Wallet(applicationSecret)\n            const canonicalData = canonicalize({ providerId: this.providerId, timestamp: this.timeStamp });\n\n\n            if (!canonicalData) {\n                throw new SignatureGeneratingError('Failed to canonicalize data for signing.');\n            }\n\n            const messageHash = ethers.keccak256(new TextEncoder().encode(canonicalData));\n\n            return await wallet.signMessage(ethers.getBytes(messageHash));\n        } catch (err) {\n            logger.info(`Error generating proof request for applicationId: ${this.applicationId}, providerId: ${this.providerId}, signature: ${this.signature}, timeStamp: ${this.timeStamp}`, err);\n            throw new SignatureGeneratingError(`Error generating signature for applicationSecret: ${applicationSecret}`)\n        }\n    }\n\n    private async buildProofRequest(provider: ProviderData): Promise<RequestedProof> {\n        try {\n            this.requestedProof = generateRequestedProof(provider);\n            return this.requestedProof;\n        } catch (err: Error | unknown) {\n            logger.info(err instanceof Error ? err.message : String(err));\n            throw new BuildProofRequestError('Something went wrong while generating proof request', err as Error);\n        }\n    }\n\n    private getRequestedProof(): RequestedProof {\n        if (!this.requestedProof) {\n            throw new BuildProofRequestError('RequestedProof is not present in the instance.')\n        }\n        return this.requestedProof\n    }\n\n    private availableParams(): string[] {\n        try {\n            const requestedProofs = this.getRequestedProof();\n            let availableParamsStore = Object.keys(requestedProofs.parameters)\n            availableParamsStore = availableParamsStore.concat(requestedProofs.url\n                .split(/{{(.*?)}}/)\n                .filter((_: string, i: number) => i % 2))\n\n            return [...new Set(availableParamsStore)];\n\n        } catch (error) {\n            logger.info(\"Error fetching available params\", error)\n            throw new AvailableParamsError(\"Error fetching available params\", error as Error)\n        }\n    }\n\n    private clearInterval(): void {\n        if (this.sessionId && this.intervals.has(this.sessionId)) {\n            clearInterval(this.intervals.get(this.sessionId) as NodeJS.Timeout)\n            this.intervals.delete(this.sessionId)\n        }\n    }\n\n    // Public methods\n    toJsonString(options?: ProofRequestOptions): string {\n        return JSON.stringify({\n            applicationId: this.applicationId,\n            providerId: this.providerId,\n            sessionId: this.sessionId,\n            context: this.context,\n            requestedProof: this.requestedProof,\n            appCallbackUrl: this.appCallbackUrl,\n            signature: this.signature,\n            redirectUrl: this.redirectUrl,\n            timeStamp: this.timeStamp,\n            options: this.options,\n            sdkVersion: this.sdkVersion,\n            jsonProofResponse: this.jsonProofResponse\n        })\n    }\n\n    async getRequestUrl(): Promise<string> {\n        logger.info('Creating Request Url')\n        if (!this.signature) {\n            throw new SignatureNotFoundError('Signature is not set.')\n        }\n\n        try {\n            const requestedProof = this.getRequestedProof()\n            validateSignature(this.providerId, this.signature, this.applicationId, this.timeStamp)\n\n            const templateData: TemplateData = {\n                sessionId: this.sessionId,\n                providerId: this.providerId,\n                applicationId: this.applicationId,\n                signature: this.signature,\n                timestamp: this.timeStamp,\n                callbackUrl: this.getAppCallbackUrl(),\n                context: JSON.stringify(this.context),\n                parameters: getFilledParameters(requestedProof),\n                redirectUrl: this.redirectUrl ?? '',\n                acceptAiProviders: this.options?.acceptAiProviders ?? false,\n                sdkVersion: this.sdkVersion,\n                jsonProofResponse: this.jsonProofResponse\n            }\n            await updateSession(this.sessionId, SessionStatus.SESSION_STARTED)\n            if (this.options?.useAppClip) {\n                let template = encodeURIComponent(JSON.stringify(templateData));\n                template = replaceAll(template, '(', '%28');\n                template = replaceAll(template, ')', '%29');\n\n                // check if the app is running on iOS or Android\n                const isIos = this.options?.device === 'ios';\n                if (!isIos) {\n                    const instantAppUrl = `https://share.reclaimprotocol.org/verify/?template=${template}`;\n                    logger.info('Instant App Url created successfully: ' + instantAppUrl);\n                    return instantAppUrl;\n                } else {\n                    const appClipUrl = `https://appclip.apple.com/id?p=org.reclaimprotocol.app.clip&template=${template}`;\n                    logger.info('App Clip Url created successfully: ' + appClipUrl);\n                    return appClipUrl;\n                }\n            } else {\n                const link = await createLinkWithTemplateData(templateData)\n                logger.info('Request Url created successfully: ' + link)\n                return link\n            }\n        } catch (error) {\n            logger.info('Error creating Request Url:', error)\n            throw error\n        }\n    }\n\n    async startSession({ onSuccess, onError }: StartSessionParams): Promise<void> {\n        if (!this.sessionId) {\n            const message = \"Session can't be started due to undefined value of sessionId\";\n            logger.info(message);\n            throw new SessionNotStartedError(message);\n        }\n\n        logger.info('Starting session');\n        const interval = setInterval(async () => {\n            try {\n                const statusUrlResponse = await fetchStatusUrl(this.sessionId);\n\n                if (!statusUrlResponse.session) return;\n\n                // Reset failure time if status is not PROOF_GENERATION_FAILED\n                if (statusUrlResponse.session.statusV2 !== SessionStatus.PROOF_GENERATION_FAILED) {\n                    this.lastFailureTime = undefined;\n                }\n\n                // Check for failure timeout\n                if (statusUrlResponse.session.statusV2 === SessionStatus.PROOF_GENERATION_FAILED) {\n                    const currentTime = Date.now();\n                    if (!this.lastFailureTime) {\n                        this.lastFailureTime = currentTime;\n                    } else if (currentTime - this.lastFailureTime >= this.FAILURE_TIMEOUT) {\n                        throw new ProviderFailedError('Proof generation failed - timeout reached');\n                    }\n                    return; // Continue monitoring if under timeout\n                }\n\n                const isDefaultCallbackUrl = this.getAppCallbackUrl() === `${constants.DEFAULT_RECLAIM_CALLBACK_URL}${this.sessionId}`;\n\n                if (isDefaultCallbackUrl) {\n                    if (statusUrlResponse.session.proofs && statusUrlResponse.session.proofs.length > 0) {\n                        const proofs = statusUrlResponse.session.proofs;\n                        const verified = await verifyProof(proofs);\n                        if (!verified) {\n                            logger.info(`Proofs not verified: ${JSON.stringify(proofs)}`);\n                            throw new ProofNotVerifiedError();\n                        }\n                        // check if the proofs array has only one proof then send the proofs in onSuccess \n                        if (proofs.length === 1) {\n                            onSuccess(proofs[0]);\n                        } else {\n                            onSuccess(proofs);\n                        }\n                        this.clearInterval();\n                    }\n                } else {\n                    if (statusUrlResponse.session.statusV2 === SessionStatus.PROOF_SUBMISSION_FAILED) {\n                        throw new ProofSubmissionFailedError();\n                    }\n                    if (statusUrlResponse.session.statusV2 === SessionStatus.PROOF_SUBMITTED) {\n                        if (onSuccess) {\n                            onSuccess('Proof submitted successfully to the custom callback url');\n                        }\n                        this.clearInterval();\n                    }\n                }\n            } catch (e) {\n                if (onError) {\n                    onError(e as Error);\n                }\n                this.clearInterval();\n            }\n        }, 3000);\n\n        this.intervals.set(this.sessionId, interval);\n        scheduleIntervalEndingTask(this.sessionId, this.intervals, onError);\n    }\n}\n\n","function createErrorClass(name: string) {\n    return class extends Error {\n        constructor(message?: string, public innerError?: Error) {\n            super(message);\n            this.name = name;\n            if (innerError) {\n                this.stack += `\\nCaused by: ${innerError.stack}`;\n            }\n        }\n    };\n}\n\nexport const TimeoutError = createErrorClass('TimeoutError');\nexport const ProofNotVerifiedError = createErrorClass('ProofNotVerifiedError');\nexport const SessionNotStartedError = createErrorClass('SessionNotStartedError');\nexport const ProviderNotFoundError = createErrorClass('ProviderNotFoundError');\nexport const BuildProofRequestError = createErrorClass('BuildProofRequestError');\nexport const SignatureGeneratingError = createErrorClass('SignatureGeneratingError');\nexport const SignatureNotFoundError = createErrorClass('SignatureNotFoundError');\nexport const InvalidSignatureError = createErrorClass('InvalidSignatureError');\nexport const UpdateSessionError = createErrorClass('UpdateSessionError');\nexport const InitSessionError = createErrorClass('InitSessionError');\nexport const ProviderFailedError = createErrorClass('ProviderFailedError');\nexport const InvalidParamError = createErrorClass('InvalidParamError');\nexport const ApplicationError = createErrorClass('ApplicationError');\nexport const InitError = createErrorClass('InitError');\nexport const AvailableParamsError = createErrorClass('AvailableParamsError')\nexport const BackendServerError = createErrorClass('BackendServerError');\nexport const GetStatusUrlError = createErrorClass('GetStatusUrlError');\nexport const NoProviderParamsError = createErrorClass('NoProviderParamsError');\nexport const SetParamsError = createErrorClass('SetParamsError');\nexport const AddContextError = createErrorClass('AddContextError');\nexport const SetSignatureError = createErrorClass('SetSignatureError');\nexport const GetAppCallbackUrlError = createErrorClass(\"GetAppCallbackUrlError\");\nexport const GetRequestUrlError = createErrorClass('GetRequestUrlError');\nexport const StatusUrlError = createErrorClass('StatusUrlError');\nexport const ProofSubmissionFailedError = createErrorClass('ProofSubmissionFailedError');","// Define the possible log levels\nexport type LogLevel = 'info' | 'warn' | 'error' | 'silent';\n\n// Define a simple logger class\nclass SimpleLogger {\n  private level: LogLevel = 'info';\n\n  setLevel(level: LogLevel) {\n    this.level = level;\n  }\n\n  private shouldLog(messageLevel: LogLevel): boolean {\n    const levels: LogLevel[] = ['error', 'warn', 'info', 'silent'];\n    return levels.indexOf(this.level) >= levels.indexOf(messageLevel);\n  }\n\n  private log(level: LogLevel, message: string, ...args: any[]) {\n    if (this.shouldLog(level) && this.level !== 'silent') {\n      const logFunction = this.getLogFunction(level);\n      console.log('current level', this.level);\n      logFunction(`[${level.toUpperCase()}]`, message, ...args);\n    }\n  }\n\n  private getLogFunction(level: LogLevel): (message?: any, ...optionalParams: any[]) => void {\n    switch (level) {\n      case 'error':\n        return console.error;\n      case 'warn':\n        return console.warn;\n      case 'info':\n        return console.info;\n      default:\n        return () => {}; // No-op for 'silent'\n    }\n  }\n\n  info(message: string, ...args: any[]) {\n    this.log('info', message, ...args);\n  }\n\n  warn(message: string, ...args: any[]) {\n    this.log('warn', message, ...args);\n  }\n\n  error(message: string, ...args: any[]) {\n    this.log('error', message, ...args);\n  }\n}\n\n// Create the logger instance\nconst logger = new SimpleLogger();\n\n// Function to set the log level\nexport function setLogLevel(level: LogLevel) {\n  logger.setLevel(level);\n}\n\n// Export the logger instance and the setLogLevel function\nexport default {\n  logger,\n  setLogLevel\n};\n","import { OnError } from './types'\nimport { TimeoutError } from './errors'\nimport loggerModule from './logger'\nconst logger = loggerModule.logger\n\n/**\n * Escapes special characters in a string for use in a regular expression\n * @param string - The input string to escape\n * @returns The input string with special regex characters escaped\n */\nexport function escapeRegExp(string: string): string {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\n/**\n * Replaces all occurrences of a substring in a string\n * @param str - The original string\n * @param find - The substring to find\n * @param replace - The string to replace the found substrings with\n * @returns A new string with all occurrences of 'find' replaced by 'replace'\n */\nexport function replaceAll(str: string, find: string, replace: string): string {\n  if (find === '') return str;\n  return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);\n}\n\n/**\n * Schedules a task to end an interval after a specified timeout\n * @param sessionId - The ID of the current session\n * @param intervals - A Map containing the intervals\n * @param onFailureCallback - Callback function to be called on failure\n * @param timeout - Timeout in milliseconds (default: 10 minutes)\n */\nexport function scheduleIntervalEndingTask(\n    sessionId: string,\n    intervals: Map<string, NodeJS.Timer>,\n    onFailureCallback: OnError,\n    timeout: number = 1000 * 60 * 10\n): void {\n    setTimeout(() => {\n        if (intervals.has(sessionId)) {\n            const message = 'Interval ended without receiving proofs'\n            onFailureCallback(new TimeoutError(message))\n            logger.info(message)\n            clearInterval(intervals.get(sessionId) as NodeJS.Timeout)\n            intervals.delete(sessionId)\n        }\n    }, timeout)\n}\n","// Base URL for the backend API\nexport const BACKEND_BASE_URL = \"https://api.reclaimprotocol.org\";\n\n// Constant values used throughout the application\nexport const constants = {\n\n    // Default callback URL for Reclaim protocol\n    DEFAULT_RECLAIM_CALLBACK_URL: `${BACKEND_BASE_URL}/api/sdk/callback?callbackId=`,\n\n    // Default status URL for Reclaim sessions\n    DEFAULT_RECLAIM_STATUS_URL: `${BACKEND_BASE_URL}/api/sdk/session/`,\n\n    // URL for sharing Reclaim templates\n    RECLAIM_SHARE_URL: 'https://share.reclaimprotocol.org/verifier/?template='\n};\n","import { ethers } from \"ethers\";\nimport { InvalidParamError, InvalidSignatureError, ProviderNotFoundError } from \"./errors\";\nimport canonicalize from 'canonicalize'\nimport { Context, RequestedProof } from \"./interfaces\";\nimport loggerModule from './logger';\nimport { ProofRequestOptions } from \"./types\";\nconst logger = loggerModule.logger;\n\n/**\n * Validates function parameters based on specified criteria\n * @param params - An array of objects containing input, paramName, and optional isString flag\n * @param functionName - The name of the function being validated\n * @throws InvalidParamError if any parameter fails validation\n */\nexport function validateFunctionParams(params: { input: any, paramName: string, isString?: boolean }[], functionName: string): void {\n  params.forEach(({ input, paramName, isString }) => {\n    if (input == null) {\n      logger.info(`Validation failed: ${paramName} in ${functionName} is null or undefined`);\n      throw new InvalidParamError(`${paramName} passed to ${functionName} must not be null or undefined.`);\n    }\n    if (isString && typeof input !== 'string') {\n      logger.info(`Validation failed: ${paramName} in ${functionName} is not a string`);\n      throw new InvalidParamError(`${paramName} passed to ${functionName} must be a string.`);\n    }\n    if (isString && input.trim() === '') {\n      logger.info(`Validation failed: ${paramName} in ${functionName} is an empty string`);\n      throw new InvalidParamError(`${paramName} passed to ${functionName} must not be an empty string.`);\n    }\n  });\n}\n\n/**\n* Validates a URL string\n* @param url - The URL to validate\n* @param functionName - The name of the function calling this validation\n* @throws InvalidParamError if the URL is invalid or empty\n*/\nexport function validateURL(url: string, functionName: string): void {\n  try {\n    new URL(url);\n  } catch (e) {\n    logger.info(`URL validation failed for ${url} in ${functionName}: ${(e as Error).message}`);\n    throw new InvalidParamError(`Invalid URL format ${url} passed to ${functionName}.`, e as Error);\n  }\n}\n\n/**\n* Validates a signature against the provided application ID\n* @param providerId - The ID of the provider\n* @param signature - The signature to validate\n* @param applicationId - The expected application ID\n* @param timestamp - The timestamp of the signature\n* @throws InvalidSignatureError if the signature is invalid or doesn't match the application ID\n*/\nexport function validateSignature(providerId: string, signature: string, applicationId: string, timestamp: string): void {\n  try {\n    logger.info(`Starting signature validation for providerId: ${providerId}, applicationId: ${applicationId}, timestamp: ${timestamp}`);\n\n    const message = canonicalize({ providerId, timestamp });\n    if (!message) {\n      logger.info('Failed to canonicalize message for signature validation');\n      throw new Error('Failed to canonicalize message');\n    }\n    const messageHash = ethers.keccak256(new TextEncoder().encode(message));\n    let appId = ethers.verifyMessage(\n      ethers.getBytes(messageHash),\n      ethers.hexlify(signature)\n    ).toLowerCase();\n\n    if (ethers.getAddress(appId) !== ethers.getAddress(applicationId)) {\n      logger.info(`Signature validation failed: Mismatch between derived appId (${appId}) and provided applicationId (${applicationId})`);\n      throw new InvalidSignatureError(`Signature does not match the application id: ${appId}`);\n    }\n\n    logger.info(`Signature validated successfully for applicationId: ${applicationId}`);\n  } catch (err) {\n    logger.info(`Signature validation failed: ${(err as Error).message}`);\n    if (err instanceof InvalidSignatureError) {\n      throw err;\n    }\n    throw new InvalidSignatureError(`Failed to validate signature: ${(err as Error).message}`);\n  }\n}\n\n\n/**\n * Validates the requested proof object\n * @param requestedProof - The requested proof object to validate\n * @throws InvalidParamError if the requested proof object is not valid\n */\nexport function validateRequestedProof(requestedProof: RequestedProof): void {\n  if (!requestedProof.url) {\n    logger.info(`Requested proof validation failed: Provided url in requested proof is not valid`);\n    throw new InvalidParamError(`The provided url in requested proof is not valid`);\n  }\n\n  if (requestedProof.parameters && typeof requestedProof.parameters !== 'object') {\n    logger.info(`Requested proof validation failed: Provided parameters in requested proof is not valid`);\n    throw new InvalidParamError(`The provided parameters in requested proof is not valid`);\n  }\n}\n\n/**\n * Validates the context object\n * @param context - The context object to validate\n * @throws InvalidParamError if the context object is not valid\n */\nexport function validateContext(context: Context): void {\n  if (!context.contextAddress) {\n    logger.info(`Context validation failed: Provided context address in context is not valid`);\n    throw new InvalidParamError(`The provided context address in context is not valid`);\n  }\n\n  if (!context.contextMessage) {\n    logger.info(`Context validation failed: Provided context message in context is not valid`);\n    throw new InvalidParamError(`The provided context message in context is not valid`);\n  }\n\n  validateFunctionParams([\n    { input: context.contextAddress, paramName: 'contextAddress', isString: true },\n    { input: context.contextMessage, paramName: 'contextMessage', isString: true }\n  ], 'validateContext');\n}\n\n/**\n * Validates the options object\n * @param options - The options object to validate\n * @throws InvalidParamError if the options object is not valid\n */\nexport function validateOptions(options: ProofRequestOptions): void {\n  if (options.acceptAiProviders && typeof options.acceptAiProviders !== 'boolean') {\n    logger.info(`Options validation failed: Provided acceptAiProviders in options is not valid`);\n    throw new InvalidParamError(`The provided acceptAiProviders in options is not valid`);\n  }\n\n  if (options.log && typeof options.log !== 'boolean') {\n    logger.info(`Options validation failed: Provided log in options is not valid`);\n    throw new InvalidParamError(`The provided log in options is not valid`);\n  }\n}\n\n\n\n","import {\n  InitSessionError,\n  UpdateSessionError,\n  StatusUrlError\n} from \"./errors\";\nimport { InitSessionResponse, SessionStatus, StatusUrlResponse } from \"./types\";\nimport { validateFunctionParams } from \"./validationUtils\";\nimport { BACKEND_BASE_URL, constants } from './constants';\nimport loggerModule from './logger';\nconst logger = loggerModule.logger;\n\n/**\n * Initializes a session with the provided parameters\n * @param providerId - The ID of the provider\n * @param appId - The ID of the application\n * @param timestamp - The timestamp of the request\n * @param signature - The signature for authentication\n * @returns A promise that resolves to an InitSessionResponse\n * @throws InitSessionError if the session initialization fails\n */\nexport async function initSession(\n  providerId: string,\n  appId: string,\n  timestamp: string,\n  signature: string\n): Promise<InitSessionResponse> {\n  logger.info(`Initializing session for providerId: ${providerId}, appId: ${appId}`);\n  try {\n    const response = await fetch(`${BACKEND_BASE_URL}/api/sdk/init-session/`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ providerId, appId, timestamp, signature })\n    });\n\n    const res = await response.json();\n\n    if (!response.ok) {\n      logger.info(`Session initialization failed: ${res.message || 'Unknown error'}`);\n      throw new InitSessionError(res.message || `Error initializing session with providerId: ${providerId}`);\n    }\n\n    return res as InitSessionResponse;\n  } catch (err) {\n    logger.info(`Failed to initialize session for providerId: ${providerId}, appId: ${appId}`, err);\n    throw err;\n  }\n}\n\n/**\n * Updates the status of an existing session\n * @param sessionId - The ID of the session to update\n * @param status - The new status of the session\n * @returns A promise that resolves to the update response\n * @throws UpdateSessionError if the session update fails\n */\nexport async function updateSession(sessionId: string, status: SessionStatus) {\n  logger.info(`Updating session status for sessionId: ${sessionId}, new status: ${status}`);\n  validateFunctionParams(\n    [{ input: sessionId, paramName: 'sessionId', isString: true }],\n    'updateSession'\n  );\n\n  try {\n    const response = await fetch(`${BACKEND_BASE_URL}/api/sdk/update/session/`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ sessionId, status })\n    });\n\n    const res = await response.json();\n\n    if (!response.ok) {\n      const errorMessage = `Error updating session with sessionId: ${sessionId}. Status Code: ${response.status}`;\n      logger.info(errorMessage, res);\n      throw new UpdateSessionError(errorMessage);\n    }\n\n    logger.info(`Session status updated successfully for sessionId: ${sessionId}`);\n    return res;\n  } catch (err) {\n    const errorMessage = `Failed to update session with sessionId: ${sessionId}`;\n    logger.info(errorMessage, err);\n    throw new UpdateSessionError(`Error updating session with sessionId: ${sessionId}`);\n  }\n}\n\n/**\n * Fetches the status URL for a given session ID\n * @param sessionId - The ID of the session to fetch the status URL for\n * @returns A promise that resolves to a StatusUrlResponse\n * @throws StatusUrlError if the status URL fetch fails\n */\nexport async function fetchStatusUrl(sessionId: string): Promise<StatusUrlResponse> {\n  validateFunctionParams(\n    [{ input: sessionId, paramName: 'sessionId', isString: true }],\n    'fetchStatusUrl'\n  );\n\n  try {\n    const response = await fetch(`${constants.DEFAULT_RECLAIM_STATUS_URL}${sessionId}`, {\n      method: 'GET',\n      headers: { 'Content-Type': 'application/json' }\n    });\n\n    const res = await response.json();\n\n    if (!response.ok) {\n      const errorMessage = `Error fetching status URL for sessionId: ${sessionId}. Status Code: ${response.status}`;\n      logger.info(errorMessage, res);\n      throw new StatusUrlError(errorMessage);\n    }\n\n    return res as StatusUrlResponse;\n  } catch (err) {\n    const errorMessage = `Failed to fetch status URL for sessionId: ${sessionId}`;\n    logger.info(errorMessage, err);\n    throw new StatusUrlError(`Error fetching status URL for sessionId: ${sessionId}`);\n  }\n}\n\n\n","import { ethers } from \"ethers\";\nimport { Context, ProviderData, RequestedProof, WitnessData } from \"./interfaces\";\nimport { SignedClaim, TemplateData } from \"./types\";\nimport { createSignDataForClaim, fetchWitnessListForClaim } from \"../witness\";\nimport { BACKEND_BASE_URL, constants } from \"./constants\";\nimport { replaceAll } from \"./helper\";\nimport { validateURL } from \"./validationUtils\";\nimport { makeBeacon } from \"../smart-contract\";\nimport { ProofNotVerifiedError } from \"./errors\";\nimport loggerModule from './logger';\nconst logger = loggerModule.logger;\n\n/**\n * Generates the requested proof for a given provider\n * @param provider - The provider details\n * @returns RequestedProof object containing the generated proof request\n */\nexport function generateRequestedProof(provider: ProviderData): RequestedProof {\n  const providerParams: { [key: string]: string } = {}\n  provider.responseSelections.forEach(rs =>\n    rs.responseMatch.split(/{{(.*?)}}/)\n      .filter((_, i) => i % 2)\n      .forEach(param => providerParams[param] = '')\n  )\n  const proof: RequestedProof = {\n    url: provider.url,\n    parameters: providerParams\n  };\n\n  return proof;\n}\n\n\n/**\n * Retrieves the parameters that have been filled with values from the requested proof\n * @param requestedProof - The requested proof object\n * @returns An object containing the parameters that have been filled with values\n */\nexport function getFilledParameters(requestedProof: RequestedProof): { [key: string]: string } {\n  return Object.keys(requestedProof.parameters).reduce<{ [key: string]: string }>((acc, param) => {\n    if (requestedProof.parameters[param]) {\n      acc[param] = requestedProof.parameters[param];\n    }\n    return acc;\n  }, {});\n}\n\n/**\n * Retrieves a shortened URL for the given URL\n * @param url - The URL to be shortened\n * @returns A promise that resolves to the shortened URL, or the original URL if shortening fails\n */\nexport async function getShortenedUrl(url: string): Promise<string> {\n  logger.info(`Attempting to shorten URL: ${url}`);\n  try {\n    validateURL(url, 'getShortenedUrl')\n    const response = await fetch(`${BACKEND_BASE_URL}/api/sdk/shortener`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ fullUrl: url })\n    })\n    const res = await response.json()\n    if (!response.ok) {\n      logger.info(`Failed to shorten URL: ${url}, Response: ${JSON.stringify(res)}`);\n      return url;\n    }\n    const shortenedVerificationUrl = res.result.shortUrl\n    return shortenedVerificationUrl\n  } catch (err) {\n    logger.info(`Error shortening URL: ${url}, Error: ${err}`);\n    return url\n  }\n}\n\n/**\n * Creates a link with embedded template data\n * @param templateData - The data to be embedded in the link\n * @returns A promise that resolves to the created link (shortened if possible)\n */\nexport async function createLinkWithTemplateData(templateData: TemplateData): Promise<string> {\n  let template = encodeURIComponent(JSON.stringify(templateData))\n  template = replaceAll(template, '(', '%28')\n  template = replaceAll(template, ')', '%29')\n\n  const fullLink = `${constants.RECLAIM_SHARE_URL}${template}`\n  try {\n    const shortenedLink = await getShortenedUrl(fullLink)\n    return shortenedLink;\n  } catch (err) {\n    logger.info(`Error creating link for sessionId: ${templateData.sessionId}, Error: ${err}`);\n    return fullLink;\n  }\n}\n\n/**\n * Retrieves the list of witnesses for a given claim\n * @param epoch - The epoch number\n * @param identifier - The claim identifier\n * @param timestampS - The timestamp in seconds\n * @returns A promise that resolves to an array of witness addresses\n * @throws Error if no beacon is available\n */\nexport async function getWitnessesForClaim(\n  epoch: number,\n  identifier: string,\n  timestampS: number\n): Promise<string[]> {\n  const beacon = makeBeacon()\n  if (!beacon) {\n    logger.info('No beacon available for getting witnesses');\n    throw new Error('No beacon available');\n  }\n  const state = await beacon.getState(epoch)\n  const witnessList = fetchWitnessListForClaim(state, identifier, timestampS)\n  const witnesses = witnessList.map((w: WitnessData) => w.id.toLowerCase())\n  return witnesses;\n}\n\n/**\n * Recovers the signers' addresses from a signed claim\n * @param claim - The signed claim object\n * @param signatures - The signatures associated with the claim\n * @returns An array of recovered signer addresses\n */\nexport function recoverSignersOfSignedClaim({\n  claim,\n  signatures\n}: SignedClaim): string[] {\n  const dataStr = createSignDataForClaim({ ...claim })\n  const signers = signatures.map(signature =>\n    ethers.verifyMessage(dataStr, ethers.hexlify(signature)).toLowerCase()\n  )\n  return signers;\n}\n\n/**\n * Asserts that a signed claim is valid by checking if all expected witnesses have signed\n * @param claim - The signed claim to validate\n * @param expectedWitnessAddresses - An array of expected witness addresses\n * @throws ProofNotVerifiedError if any expected witness signature is missing\n */\nexport function assertValidSignedClaim(\n  claim: SignedClaim,\n  expectedWitnessAddresses: string[]\n): void {\n  const witnessAddresses = recoverSignersOfSignedClaim(claim)\n  const witnessesNotSeen = new Set(expectedWitnessAddresses)\n  for (const witness of witnessAddresses) {\n    if (witnessesNotSeen.has(witness)) {\n      witnessesNotSeen.delete(witness)\n    }\n  }\n\n  if (witnessesNotSeen.size > 0) {\n    const missingWitnesses = Array.from(witnessesNotSeen).join(', ');\n    logger.info(`Claim validation failed. Missing signatures from: ${missingWitnesses}`);\n    throw new ProofNotVerifiedError(\n      `Missing signatures from ${missingWitnesses}`\n    )\n  }\n}","/* Autogenerated file. Do not edit manually. */\n/* tslint:disable */\n\nimport { Contract } from 'ethers';\n\nconst _abi = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'previousAdmin',\n        type: 'address',\n      },\n      {\n        indexed: false,\n        internalType: 'address',\n        name: 'newAdmin',\n        type: 'address',\n      },\n    ],\n    name: 'AdminChanged',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'beacon',\n        type: 'address',\n      },\n    ],\n    name: 'BeaconUpgraded',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        components: [\n          {\n            internalType: 'uint32',\n            name: 'id',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint32',\n            name: 'timestampStart',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint32',\n            name: 'timestampEnd',\n            type: 'uint32',\n          },\n          {\n            components: [\n              {\n                internalType: 'address',\n                name: 'addr',\n                type: 'address',\n              },\n              {\n                internalType: 'string',\n                name: 'host',\n                type: 'string',\n              },\n            ],\n            internalType: 'struct Reclaim.Witness[]',\n            name: 'witnesses',\n            type: 'tuple[]',\n          },\n          {\n            internalType: 'uint8',\n            name: 'minimumWitnessesForClaimCreation',\n            type: 'uint8',\n          },\n        ],\n        indexed: false,\n        internalType: 'struct Reclaim.Epoch',\n        name: 'epoch',\n        type: 'tuple',\n      },\n    ],\n    name: 'EpochAdded',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: 'uint8',\n        name: 'version',\n        type: 'uint8',\n      },\n    ],\n    name: 'Initialized',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'previousOwner',\n        type: 'address',\n      },\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'newOwner',\n        type: 'address',\n      },\n    ],\n    name: 'OwnershipTransferred',\n    type: 'event',\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: 'address',\n        name: 'implementation',\n        type: 'address',\n      },\n    ],\n    name: 'Upgraded',\n    type: 'event',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'witnessAddress',\n        type: 'address',\n      },\n      {\n        internalType: 'string',\n        name: 'host',\n        type: 'string',\n      },\n    ],\n    name: 'addAsWitness',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'addNewEpoch',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint32',\n        name: 'epochNum',\n        type: 'uint32',\n      },\n      {\n        components: [\n          {\n            internalType: 'string',\n            name: 'provider',\n            type: 'string',\n          },\n          {\n            internalType: 'string',\n            name: 'parameters',\n            type: 'string',\n          },\n          {\n            internalType: 'string',\n            name: 'context',\n            type: 'string',\n          },\n        ],\n        internalType: 'struct Claims.ClaimInfo',\n        name: 'claimInfo',\n        type: 'tuple',\n      },\n      {\n        components: [\n          {\n            internalType: 'bytes32',\n            name: 'identifier',\n            type: 'bytes32',\n          },\n          {\n            internalType: 'address',\n            name: 'owner',\n            type: 'address',\n          },\n          {\n            internalType: 'uint32',\n            name: 'timestampS',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint256',\n            name: 'epoch',\n            type: 'uint256',\n          },\n        ],\n        internalType: 'struct Claims.CompleteClaimData',\n        name: 'claimData',\n        type: 'tuple',\n      },\n      {\n        internalType: 'bytes[]',\n        name: 'signatures',\n        type: 'bytes[]',\n      },\n    ],\n    name: 'assertValidEpochAndSignedClaim',\n    outputs: [],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'currentEpoch',\n    outputs: [\n      {\n        internalType: 'uint32',\n        name: '',\n        type: 'uint32',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'epochDurationS',\n    outputs: [\n      {\n        internalType: 'uint32',\n        name: '',\n        type: 'uint32',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    name: 'epochs',\n    outputs: [\n      {\n        internalType: 'uint32',\n        name: 'id',\n        type: 'uint32',\n      },\n      {\n        internalType: 'uint32',\n        name: 'timestampStart',\n        type: 'uint32',\n      },\n      {\n        internalType: 'uint32',\n        name: 'timestampEnd',\n        type: 'uint32',\n      },\n      {\n        internalType: 'uint8',\n        name: 'minimumWitnessesForClaimCreation',\n        type: 'uint8',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint32',\n        name: 'epoch',\n        type: 'uint32',\n      },\n    ],\n    name: 'fetchEpoch',\n    outputs: [\n      {\n        components: [\n          {\n            internalType: 'uint32',\n            name: 'id',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint32',\n            name: 'timestampStart',\n            type: 'uint32',\n          },\n          {\n            internalType: 'uint32',\n            name: 'timestampEnd',\n            type: 'uint32',\n          },\n          {\n            components: [\n              {\n                internalType: 'address',\n                name: 'addr',\n                type: 'address',\n              },\n              {\n                internalType: 'string',\n                name: 'host',\n                type: 'string',\n              },\n            ],\n            internalType: 'struct Reclaim.Witness[]',\n            name: 'witnesses',\n            type: 'tuple[]',\n          },\n          {\n            internalType: 'uint8',\n            name: 'minimumWitnessesForClaimCreation',\n            type: 'uint8',\n          },\n        ],\n        internalType: 'struct Reclaim.Epoch',\n        name: '',\n        type: 'tuple',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint32',\n        name: 'epoch',\n        type: 'uint32',\n      },\n      {\n        internalType: 'bytes32',\n        name: 'identifier',\n        type: 'bytes32',\n      },\n      {\n        internalType: 'uint32',\n        name: 'timestampS',\n        type: 'uint32',\n      },\n    ],\n    name: 'fetchWitnessesForClaim',\n    outputs: [\n      {\n        components: [\n          {\n            internalType: 'address',\n            name: 'addr',\n            type: 'address',\n          },\n          {\n            internalType: 'string',\n            name: 'host',\n            type: 'string',\n          },\n        ],\n        internalType: 'struct Reclaim.Witness[]',\n        name: '',\n        type: 'tuple[]',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'initialize',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'minimumWitnessesForClaimCreation',\n    outputs: [\n      {\n        internalType: 'uint8',\n        name: '',\n        type: 'uint8',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'owner',\n    outputs: [\n      {\n        internalType: 'address',\n        name: '',\n        type: 'address',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'proxiableUUID',\n    outputs: [\n      {\n        internalType: 'bytes32',\n        name: '',\n        type: 'bytes32',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'witnessAddress',\n        type: 'address',\n      },\n    ],\n    name: 'removeAsWitness',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [],\n    name: 'renounceOwnership',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'newOwner',\n        type: 'address',\n      },\n    ],\n    name: 'transferOwnership',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'addr',\n        type: 'address',\n      },\n      {\n        internalType: 'bool',\n        name: 'isWhitelisted',\n        type: 'bool',\n      },\n    ],\n    name: 'updateWitnessWhitelist',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'newImplementation',\n        type: 'address',\n      },\n    ],\n    name: 'upgradeTo',\n    outputs: [],\n    stateMutability: 'nonpayable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'address',\n        name: 'newImplementation',\n        type: 'address',\n      },\n      {\n        internalType: 'bytes',\n        name: 'data',\n        type: 'bytes',\n      },\n    ],\n    name: 'upgradeToAndCall',\n    outputs: [],\n    stateMutability: 'payable',\n    type: 'function',\n  },\n  {\n    inputs: [\n      {\n        internalType: 'uint256',\n        name: '',\n        type: 'uint256',\n      },\n    ],\n    name: 'witnesses',\n    outputs: [\n      {\n        internalType: 'address',\n        name: 'addr',\n        type: 'address',\n      },\n      {\n        internalType: 'string',\n        name: 'host',\n        type: 'string',\n      },\n    ],\n    stateMutability: 'view',\n    type: 'function',\n  },\n] as const;\n\nexport class Reclaim__factory {\n  static readonly abi = _abi;\n\n  static connect(address: string, signerOrProvider: any): Contract {\n    return new Contract(address, _abi, signerOrProvider);\n  }\n}\n","{\n  \"0x1a4\": {\n    \"chainName\": \"opt-goerli\",\n    \"address\": \"0xF93F605142Fb1Efad7Aa58253dDffF67775b4520\",\n    \"rpcUrl\": \"https://opt-goerli.g.alchemy.com/v2/rksDkSUXd2dyk2ANy_zzODknx_AAokui\"\n  },\n  \"0xaa37dc\": {\n    \"chainName\": \"opt-sepolia\",\n    \"address\": \"0x6D0f81BDA11995f25921aAd5B43359630E65Ca96\",\n    \"rpcUrl\": \"https://opt-sepolia.g.alchemy.com/v2/aO1-SfG4oFRLyAiLREqzyAUu0HTCwHgs\"\n}\n\n}\n","import type { Beacon, BeaconState } from './utils/interfaces';\nimport { Reclaim__factory as ReclaimFactory } from './contract-types';\nimport CONTRACTS_CONFIG from './contract-types/config.json';\nimport { Contract, ethers } from 'ethers';\n\nconst DEFAULT_CHAIN_ID = 11155420;\n\nexport function makeBeacon(chainId?: number): Beacon | undefined {\n  chainId = chainId || DEFAULT_CHAIN_ID;\n  const contract = getContract(chainId);\n  if (contract) {\n    return makeBeaconCacheable({\n      async getState(epochId: number | undefined): Promise<BeaconState> {\n        //@ts-ignore\n        const epoch = await contract.fetchEpoch(epochId || 0);\n        if (!epoch.id) {\n          throw new Error(`Invalid epoch ID: ${epochId}`);\n        }\n\n        return {\n          epoch: epoch.id,\n          witnesses: epoch.witnesses.map((w: any) => ({\n            id: w.addr.toLowerCase(),\n            url: w.host,\n          })),\n          witnessesRequiredForClaim: epoch.minimumWitnessesForClaimCreation,\n          nextEpochTimestampS: epoch.timestampEnd,\n        };\n      },\n    });\n  } else {\n    return undefined;\n  }\n}\n\nexport function makeBeaconCacheable(beacon: Beacon): Beacon {\n  const cache: { [epochId: number]: Promise<BeaconState> } = {};\n\n  return {\n    ...beacon,\n    async getState(epochId: number | undefined): Promise<BeaconState> {\n      if (!epochId) {\n        // TODO: add cache here\n        const state = await beacon.getState();\n        return state;\n      }\n\n      const key = epochId;\n\n      if (!cache[key]) {\n        cache[key] = beacon.getState(epochId);\n      }\n\n      return cache[key] as unknown as BeaconState;\n    },\n  };\n}\n\nconst existingContractsMap: { [chain: string]: Contract } = {};\n\nfunction getContract(chainId: number): Contract {\n  const chainKey = `0x${chainId.toString(16)}`;\n  if (!existingContractsMap[chainKey]) {\n    const contractData =\n      CONTRACTS_CONFIG[chainKey as keyof typeof CONTRACTS_CONFIG];\n    if (!contractData) {\n      throw new Error(`Unsupported chain: \"${chainKey}\"`);\n    }\n\n    const rpcProvider = new ethers.JsonRpcProvider(contractData.rpcUrl);\n    existingContractsMap[chainKey] = ReclaimFactory.connect(\n      contractData.address,\n      rpcProvider\n    );\n  }\n\n  return existingContractsMap[chainKey] as Contract;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}